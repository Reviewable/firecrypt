var FireCrypt=function(){"use strict";class t{constructor(t,e){this._spec=this._cleanSpecification(e),this._encryptString=this._throwNotSetUpError,this._decryptString=this._throwNotSetUpError,this._patternRegexes={},"function"==typeof LRUCache&&(this._encryptionCache=new LRUCache({max:t.encryptionCacheSize,length:this._computeCacheItemSize}),this._decryptionCache=new LRUCache({max:t.decryptionCacheSize,length:this._computeCacheItemSize}))}_cleanSpecification(t,e){for(var r=Object.keys(t),n=0;n<r.length;n++){var i=r[n];if(".encrypt"===i)for(var s=Object.keys(t[i]),o=0;o<s.length;o++){var c=s[o];if("key"!==c&&"value"!==c&&"few"!==c)throw new Error("Illegal .encrypt subkey: "+s[o])}else{if(/[\x00-\x1f\x7f\x91\x92\.#\[\]/]/.test(i)||/[$]/.test(i.slice(1)))throw new Error("Illegal character in specification key: "+i);this._cleanSpecification(t[i],(e||"")+"/"+i)}switch(i.charAt(0)){case"$":if("$"===i)break;if(t.$)throw new Error("Multiple wildcard keys in specification at "+e);t.$=t[i],delete t[i];break;case".":if(".encrypt"!==i)throw new Error("Unknown directive at "+e+": "+i)}}return t}_throwNotSetUpError(){var t=new Error("Encryption not set up");throw t.firecrypt="NO_KEY",t}_computeCacheItemSize(t,e){return e.length+("string"==typeof t?t.length:4)}setStringEncryptionFunctions(t,e){this._encryptString=t,this._decryptString=e}encryptPath(t,e){e=e||this._spec.rules,t=t.slice();for(var r=0;r<t.length&&(e=e[t[r]]||e.$);r++)e[".encrypt"]&&e[".encrypt"].key&&(t[r]=this.encrypt(t[r],"string",e[".encrypt"].key));return t}encryptRef(t,e){var r=this.encryptPath(e||this.refToPath(t));return r.length?t.root.child(r.join("/")):t.root}decryptRef(t){for(var e=this.refToPath(t,!0),r=!1,n=0;n<e.length;n++){var i=this.decrypt(e[n]);i!==e[n]&&(e[n]=i,r=!0)}return r?t.root.child(e.join("/")):t}specForPath(t,e){e=e||this._spec.rules;for(var r=0;e&&r<t.length;r++)e=e[t[r]]||e.$;return e}transformValue(t,e,r){if("encrypt"!==r&&"decrypt"!==r)throw new Error(`Transform type must be either "encrypt" or "decrypt", but got "${r}".`);const n="encrypt"===r?this.encrypt.bind(this):this.decrypt.bind(this);return this.transformTree(e,this.specForPath(t),n)}transformTree(t,e,r){if(!e)return t;var n,i=this.getType(t);if(/^(string|number|boolean)$/.test(i))e[".encrypt"]&&e[".encrypt"].value&&(t=r(t,i,e[".encrypt"].value));else if("object"===i&&null!==t){var s={};for(var o in t)if(t.hasOwnProperty(o)){var c,h=t[o];if(o.indexOf("/")>=0){var a=o.split("/");for(c=e,n=0;n<a.length;n++)r===decrypt?(a[n]=this.decrypt(a[n]),c=c&&(c[a[n]]||c.$)):(c=c&&(c[a[n]]||c.$))&&c[".encrypt"]&&c[".encrypt"].key&&(a[n]=r(a[n],"string",c[".encrypt"].key));o=a.join("/")}else r===this.decrypt?c=e[o=this.decrypt(o)]||e.$:(c=e[o]||e.$)&&c[".encrypt"]&&c[".encrypt"].key&&(o=r(o,"string",c[".encrypt"].key));s[o]=this.transformTree(h,c,r)}t=s}else if("array"===i){if(!e.$)return t;for(n=0;n<t.length;n++)t[n]=this.transformTree(t[n],e.$,r)}return t}refToPath(t,e){var r=t.root;if(t===r)return[];var n=decodeURIComponent(t.toString().slice(r.toString().length));if(!e&&n&&"."!==n.charAt(0)&&/[\x00-\x1f\x7f\x91\x92\.#$\[\]]/.test(n))throw new Error("Path contains invalid characters: "+n);return n.split("/")}encrypt(t,e,r){var n,i;if(this._encryptionCache&&(n=e.charAt(0)+r+""+t,this._encryptionCache.has(n)))return this._encryptionCache.get(n);if("#"===r)i=this.encryptValue(t,e);else{if("string"!==e)throw new Error("Can't encrypt a "+e+" using pattern ["+r+"]");var s=t.match(this.compilePattern(r));if(!s)throw new Error("Can't encrypt as value doesn't match pattern ["+r+"]: "+t);var o=0;i=r.replace(/[#\.]/g,function(t){var e=s[++o];return"#"===t&&(e=this.encryptValue(e,"string")),e})}return this._encryptionCache&&this._encryptionCache.set(n,i),i}encryptValue(t,e){if(!/^(string|number|boolean)$/.test(e))throw new Error("Can't encrypt a "+e);switch(e){case"number":t=""+t;break;case"boolean":t=t?"t":"f"}return""+e.charAt(0).toUpperCase()+this._encryptString(t)+""}decrypt(t){if(this._decryptionCache&&this._decryptionCache.has(t))return this._decryptionCache.get(t);if(!/\x91/.test(t))return t;var e,r=t.match(/^\x91(.)([^\x92]*)\x92$/);if(r){var n=this._decryptString(r[2]);switch(r[1]){case"S":e=n;break;case"N":if((e=Number(n))!=e)throw new Error("Invalid encrypted number: "+n);break;case"B":if("t"===n)e=!0;else{if("f"!==n)throw new Error("Invalid encrypted boolean: "+n);e=!1}break;default:throw new Error("Invalid encrypted value type code: "+r[1])}}else e=t.replace(/\x91(.)([^\x92]*)\x92/g,function(t,e,r){if("S"!==e)throw new Error("Invalid multi-segment encrypted value: "+e);return this._decryptString(r)});return this._decryptionCache&&this._decryptionCache.set(t,e),e}getType(t){if(Array.isArray(t))return"array";var e=typeof t;return"object"===e&&(t instanceof String?e="string":t instanceof Number?e="number":t instanceof Boolean&&(e="boolean")),e}compilePattern(t){var e=this._patternRegexes[t];return e||(e=this._patternRegexes[t]=new RegExp("^"+t.replace(/\./g,"#").replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&").replace(/#/g,"(.*?)")+"$")),e}}class e{constructor(t,e){this._ref=e.decryptRef(t.ref),this._path=e.refToPath(this._ref),this._snap=t,this._crypto=e}get key(){return this._ref.key}get ref(){return new i(this._ref.ref,this._crypto)}val(){return this._crypto.transformValue(this._path,this._snap.val(),"decrypt")}child(t){return new e(this._snap.child(t),this._crypto)}forEach(t){return this._snap.forEach(r=>t(new e(r),this._crypto))}exists(){return this._snap.exists.apply(this._snap,arguments)}hasChild(t){return t=this._crypto.encryptPath(t.split("/"),this._crypto.specForPath(this._path)).join("/"),this._snap.hasChild(t)}hasChildren(){return this._snap.hasChildren.apply(this._snap,arguments)}numChildren(){return this._snap.numChildren.apply(this._snap,arguments)}toJSON(){const t=this._snap.toJSON.apply(this._snap,arguments);return this._crypto.transformValue(this._path,t,"decrypt")}}class r{constructor(t,e,r,n){this._query=t,this._order=e||{},this._originalRef=r||t,this._crypto=n}_wrapQueryCallback(t){if(!t||t.firecryptCallback)return;const r=(r,n)=>t.call(this,new e(r,this._crypto),n,this._crypto);r.firecryptCallback=r,t.firecryptCallback=r}get ref(){return new i(this._crypto.decryptRef(this._query.ref),this._crypto)}on(t,e,r,n){return this._wrapQueryCallback(e),this._originalRef.on.call(this._query,t,e.firecryptCallback,r,n)}off(t,e,r){return e&&e.firecryptCallback&&(e=e.firecryptCallback),this._originalRef.off.call(this._query,t,e,r)}once(t,r,n,i){return this._wrapQueryCallback(r),this._originalRef.once.call(this._query,t,r&&r.firecryptCallback,n,i).then(t=>new e(t,this._crypto))}orderByChild(t){return this._orderBy("orderByChild","child",t)}orderByKey(){return this._orderBy("orderByKey","key")}orderByValue(){return this._orderBy("orderByValue","value")}startAt(t,e){return this._checkCanSort(void 0!==e),this._delegate("startAt",arguments)}endAt(t,e){return this._checkCanSort(void 0!==e),this._delegate("endAt",arguments)}equalTo(t,e){return this._order[this._order.by+"Encrypted"]&&(t=this._crypto.encrypt(t,this._crypto.getType(t),this._order[this._order.by+"Encrypted"])),void 0!==e&&this._order.keyEncrypted&&(e=this._crypto.encrypt(e,"string",this._order.keyEncrypted)),new r(this._originalRef.equalTo.call(this._query,t,e),this._order,this._crypto)}limitToFirst(){return this._delegate("limitToFirst",arguments)}limitToLast(){return this._delegate("limitToLast",arguments)}limit(){return this._delegate("limit",arguments)}_delegate(t,e){return new r(this._originalRef[t].apply(this._query,e),this._order,this._crypto)}_checkCanSort(t){if("key"===this._order.by?this._order.keyEncrypted:this._order.valueEncrypted||t&&this._order.keyEncrypted)throw new Error("Encrypted items cannot be ordered")}_orderBy(t,e,n){const i=this._crypto.specForPath(this._crypto.refToPath(this.ref)),s={by:e};let o;if(i){const t=n&&n.split("/");for(const e in i){if(!i.hasOwnProperty(e))continue;const r=i[e];if(r[".encrypt"]&&(r[".encrypt"].key&&(s.keyEncrypted=r[".encrypt"].key),r[".encrypt"].value&&(s.valueEncrypted=r[".encrypt"].value)),n){const e=this._crypto.specForPath(t,r);e&&e[".encrypt"]&&e[".encrypt"].value&&(s.childEncrypted=e[".encrypt"].value);const i=this._crypto.encryptPath(t,r).join("/");if(o&&i!==o)throw new Error('Incompatible encryption specifications for orderByChild("'+n+'")');o=i}}}return new r(n?this._originalRef[t].call(this._query,o||n):this._originalRef[t].call(this._query),s,this._crypto)}}class n{constructor(t,e,r){this._path=t,this._crypto=r,this._originalOnDisconnect=e}_interceptOnDisconnectWrite(t,e,r){const n=this;this[t]=function(){const i=Array.prototype.slice.call(e);return r>=0&&r<i.length&&(i[r]=n._crypto.transformValue(n._path,i[r],"encrypt")),n._originalOnDisconnect[t].apply(n._originalOnDisconnect,i)}}set(){return this._interceptOnDisconnectWrite("set",arguments,0)}update(){return this._interceptOnDisconnectWrite("update",arguments,0)}remove(){return this._interceptOnDisconnectWrite("remove",arguments)}cancel(){return this._interceptOnDisconnectWrite("cancel",arguments)}}class i{constructor(t,e){this._ref=t,this._crypto=e}_interceptQuery(t,e){const n=this._crypto.encryptRef(this._ref),i=new r(n,{},this._ref,this._crypto);return i[t].apply(i,e)}_interceptWrite(t,e,r){const n=this._crypto.encryptRef(this._ref),i=Array.prototype.slice.call(e);if(r>=0&&r<i.length){const t=this._crypto.refToPath(this._ref);i[r]=this._crypto.transformValue(t,i[r],"encrypt")}return this._ref[t].apply(n,i)}static get SERVER_TIMESTAMP(){return{".sv":"timestamp"}}get key(){return this._ref.key}get path(){return decodeURIComponent(this._ref.toString()).slice(this._ref.root.toString().length-1)}get ref(){return this._ref.isEqual(this._ref.ref)?this:new i(this._ref.ref,this._crypto)}get root(){return this._ref.isEqual(this._ref.root)?this:new i(this._ref.root,this._crypto)}get parent(){return null===this._ref.parent?null:new i(this._ref.parent,this._crypto)}child(t){return new i(this._ref.child(t),this._crypto)}toJSON(){return this._ref.toJSON()}isEqual(t){return this._ref.isEqual(t._ref)}toString(){return decodeURIComponent(this._ref.toString())}push(){const t=this.child(this._ref.push().key);let e;return e=void 0===arguments[0]?Promise.resolve():t.set.apply(t,arguments),t.then=e.then.bind(e),t.catch=e.catch.bind(e),e.finally&&(t.finally=e.finally.bind(e)),t}set(){return this._interceptWrite("set",arguments,0)}remove(){return this._interceptWrite("remove",arguments)}update(){return this._interceptWrite("update",arguments,0)}childrenKeys(){if(!this._ref.childrenKeys)throw new Error("childrenKeys() is not implemented.");const t=this._crypto.encryptRef(this._ref);return this._ref.childrenKeys.apply(t,arguments).then(t=>t.some(t=>/\x91/.test(t))?t.map(this._crypto.decrypt.bind(this._crypto)):t)}onDisconnect(){const t=this._crypto.encryptRef(this._ref);return new n(t,this._ref.onDisconnect.call(t),this._crypto)}on(){return this._interceptQuery("on",arguments)}off(){return this._interceptQuery("off",arguments)}once(){return this._interceptQuery("once",arguments)}orderByChild(){return this._interceptQuery("orderByChild",arguments)}orderByKey(){return this._interceptQuery("orderByKey",arguments)}orderByValue(){return this._interceptQuery("orderByValue",arguments)}startAt(){return this._interceptQuery("startAt",arguments)}endAt(){return this._interceptQuery("endAt",arguments)}equalTo(){return this._interceptQuery("equalTo",arguments)}limitToFirst(){return this._interceptQuery("limitToFirst",arguments)}limitToLast(){return this._interceptQuery("limitToLast",arguments)}transaction(){const t=this._crypto.encryptRef(this._ref),r=this._crypto.refToPath(this._ref),n=Array.prototype.slice.call(arguments),i=n[0];if(n[0]=i&&(t=>(t=this._crypto.transformValue(r,t,"decrypt"),t=i(t),t=this._crypto.transformValue(r,t,"encrypt"))),n.length>1){const t=n[1];n[1]=t&&((r,n,i)=>t(r,n,i&&new e(i)))}return this._ref.transaction.apply(t,n).then(t=>(t.snapshot=t.snapshot&&new e(t.snapshot,this._crypto),t))}}"undefined"!=typeof require&&("undefined"==typeof LRUCache&&(global.LRUCache=require("lru-cache")),"undefined"==typeof CryptoJS&&(global.CryptoJS=require("crypto-js/core")),require("crypto-js/enc-base64"),require("cryptojs-extension/build_node/siv")),CryptoJS.enc.Base64UrlSafe={stringify:CryptoJS.enc.Base64.stringify,parse:CryptoJS.enc.Base64.parse,_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"};return class{constructor(t){if("object"!=typeof t||null===t||"object"!=typeof t.app||"function"!=typeof t.ref)throw new Error(`Expected first argument passed to FireCrypt constructor to be a Firebase Database instance, \n        but got "${t}".`);this._db=t,this._crypto=void 0}_ensureEncryptionConfigured(){if(void 0===this._crypto)throw new Error("Encryption for this FireCrypt reference has not been configured yet.")}_setupAesSiv(t,e){const r=CryptoJS.SIV.create(CryptoJS.enc.Base64.parse(t)),n=t=>CryptoJS.enc.Base64UrlSafe.stringify(r.encrypt(t)),i=t=>{const e=r.decrypt(CryptoJS.enc.Base64UrlSafe.parse(t));if(!1===e){const t=new Error("Wrong decryption key");throw t.firecrypt="WRONG_KEY",t}return CryptoJS.enc.Utf8.stringify(e)};return this._crypto.setStringEncryptionFunctions(n,i),e&&i(e),n(CryptoJS.enc.Base64UrlSafe.stringify(CryptoJS.lib.WordArray.random(10)))}get app(){return this._ensureEncryptionConfigured(),this._db.app}configureEncryption(e={},r={}){if("object"!=typeof e||null===e)throw new Error(`Expected second argument passed to configureEncryption() to be an object, but got "${e}".`);if("object"!=typeof r||null===r)throw new Error(`Expected third argument passed to configureEncryption() to be an object, but got "${r}".`);let n;switch(e.cacheSize=e.cacheSize||5e6,e.encryptionCacheSize=e.encryptionCacheSize||e.cacheSize,e.decryptionCacheSize=e.decryptionCacheSize||e.cacheSize,this._crypto=new t(e,r),e.algorithm){case"aes-siv":if(!e.key)throw new Error("You must specify a key to use AES encryption.");n=this._setupAesSiv(e.key,e.keyCheckValue);break;case"passthrough":this._crypto.setStringEncryptionFunctions(t=>t,t=>t);break;case"none":break;default:throw new Error('Unknown encryption algorithm "'+e.algorithm+'".')}return n}goOnline(){return this._ensureEncryptionConfigured(),this._db.goOnline()}goOffline(){return this._ensureEncryptionConfigured(),this._db.goOffline()}ref(t){if(this._ensureEncryptionConfigured(),void 0!==t&&"string"!=typeof t)throw new Error(`Expected first argument passed to ref() to be undefined or a string, but got "${t}".`);return new i(this._db.ref(t),this._crypto)}refFromURL(t){if(this._ensureEncryptionConfigured(),"string"!=typeof t||null===t.match(/^https:\/\/.*/g))throw new Error(`Expected first argument passed to refFromURL() to be a string URL, but got "${t}".`);return new i(this._db.refFromURL(path),this._crypto)}}}();
//# sourceMappingURL=firecrypt.min.js.map
