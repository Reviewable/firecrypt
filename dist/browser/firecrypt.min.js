!function(){"use strict";class t{constructor(t,e){this._spec=this._cleanSpecification(e),this._encryptString=this._throwNotSetUpError,this._decryptString=this._throwNotSetUpError,this._patternRegexes={},"function"==typeof LRUCache&&(this._encryptionCache=new LRUCache({max:t.encryptionCacheSize,length:this._computeCacheItemSize}),this._decryptionCache=new LRUCache({max:t.decryptionCacheSize,length:this._computeCacheItemSize}))}_cleanSpecification(t,e){for(var r=Object.keys(t),i=0;i<r.length;i++){var n=r[i];if(".encrypt"===n)for(var s=Object.keys(t[n]),o=0;o<s.length;o++){var c=s[o];if("key"!==c&&"value"!==c&&"few"!==c)throw new Error("Illegal .encrypt subkey: "+s[o])}else{if(/[\x00-\x1f\x7f\x91\x92\.#\[\]/]/.test(n)||/[$]/.test(n.slice(1)))throw new Error("Illegal character in specification key: "+n);this._cleanSpecification(t[n],(e||"")+"/"+n)}switch(n.charAt(0)){case"$":if("$"===n)break;if(t.$)throw new Error("Multiple wildcard keys in specification at "+e);t.$=t[n],delete t[n];break;case".":if(".encrypt"!==n)throw new Error("Unknown directive at "+e+": "+n)}}return t}_throwNotSetUpError(){var t=new Error("Encryption not set up");throw t.firecrypt="NO_KEY",t}_computeCacheItemSize(t,e){return e.length+("string"==typeof t?t.length:4)}setStringEncryptionFunctions(t,e){this._encryptString=t,this._decryptString=e}encryptPath(t,e){e=e||this._spec.rules,t=t.slice();for(var r=0;r<t.length&&(e=e[t[r]]||e.$);r++)e[".encrypt"]&&e[".encrypt"].key&&(t[r]=this.encrypt(t[r],"string",e[".encrypt"].key));return t}encryptRef(t,e){var r=this.encryptPath(e||this.refToPath(t));return r.length?t.root.child(r.join("/")):t.root}decryptRef(t){for(var e=this.refToPath(t,!0),r=!1,i=0;i<e.length;i++){var n=this.decrypt(e[i]);n!==e[i]&&(e[i]=n,r=!0)}return r?t.root.child(e.join("/")):t}specForPath(t,e){e=e||this._spec.rules;for(var r=0;e&&r<t.length;r++)e=e[t[r]]||e.$;return e}transformValue(t,e,r){if("encrypt"!==r&&"decrypt"!==r)throw new Error(`Transform type must be either "encrypt" or "decrypt", but got "${r}".`);const i="encrypt"===r?this.encrypt.bind(this):this.decrypt.bind(this);return this.transformTree(e,this.specForPath(t),i)}transformTree(t,e,r){if(!e)return t;var i,n=this.getType(t);if(/^(string|number|boolean)$/.test(n))e[".encrypt"]&&e[".encrypt"].value&&(t=r(t,n,e[".encrypt"].value));else if("object"===n&&null!==t){var s={};for(var o in t)if(t.hasOwnProperty(o)){var c,a=t[o];if(o.indexOf("/")>=0){var h=o.split("/");for(c=e,i=0;i<h.length;i++)r===this.decrypt?(h[i]=this.decrypt(h[i]),c=c&&(c[h[i]]||c.$)):(c=c&&(c[h[i]]||c.$))&&c[".encrypt"]&&c[".encrypt"].key&&(h[i]=r(h[i],"string",c[".encrypt"].key));o=h.join("/")}else r===this.decrypt?c=e[o=this.decrypt(o)]||e.$:(c=e[o]||e.$)&&c[".encrypt"]&&c[".encrypt"].key&&(o=r(o,"string",c[".encrypt"].key));s[o]=this.transformTree(a,c,r)}t=s}else if("array"===n){if(!e.$)return t;for(i=0;i<t.length;i++)t[i]=this.transformTree(t[i],e.$,r)}return t}refToPath(t,e){var r=t.root;if(t===r)return[];var i=decodeURIComponent(t.toString().slice(r.toString().length));if(!e&&i&&"."!==i.charAt(0)&&/[\x00-\x1f\x7f\x91\x92\.#$\[\]]/.test(i))throw new Error("Path contains invalid characters: "+i);return i.split("/")}encrypt(t,e,r){var i,n;if(this._encryptionCache&&(i=e.charAt(0)+r+""+t,this._encryptionCache.has(i)))return this._encryptionCache.get(i);if("#"===r)n=this.encryptValue(t,e);else{if("string"!==e)throw new Error("Can't encrypt a "+e+" using pattern ["+r+"]");var s=t.match(this.compilePattern(r));if(!s)throw new Error("Can't encrypt as value doesn't match pattern ["+r+"]: "+t);var o=0;n=r.replace(/[#\.]/g,t=>{var e=s[++o];return"#"===t&&(e=this.encryptValue(e,"string")),e})}return this._encryptionCache&&this._encryptionCache.set(i,n),n}encryptValue(t,e){if(!/^(string|number|boolean)$/.test(e))throw new Error("Can't encrypt a "+e);switch(e){case"number":t=""+t;break;case"boolean":t=t?"t":"f"}return""+e.charAt(0).toUpperCase()+this._encryptString(t)+""}decrypt(t){if(this._decryptionCache&&this._decryptionCache.has(t))return this._decryptionCache.get(t);if(!/\x91/.test(t))return t;var e,r=t.match(/^\x91(.)([^\x92]*)\x92$/);if(r){var i=this._decryptString(r[2]);switch(r[1]){case"S":e=i;break;case"N":if((e=Number(i))!=e)throw new Error("Invalid encrypted number: "+i);break;case"B":if("t"===i)e=!0;else{if("f"!==i)throw new Error("Invalid encrypted boolean: "+i);e=!1}break;default:throw new Error("Invalid encrypted value type code: "+r[1])}}else e=t.replace(/\x91(.)([^\x92]*)\x92/g,(t,e,r)=>{if("S"!==e)throw new Error("Invalid multi-segment encrypted value: "+e);return this._decryptString(r)});return this._decryptionCache&&this._decryptionCache.set(t,e),e}getType(t){if(Array.isArray(t))return"array";var e=typeof t;return"object"===e&&(t instanceof String?e="string":t instanceof Number?e="number":t instanceof Boolean&&(e="boolean")),e}compilePattern(t){var e=this._patternRegexes[t];return e||(e=this._patternRegexes[t]=new RegExp("^"+t.replace(/\./g,"#").replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&").replace(/#/g,"(.*?)")+"$")),e}}class e{constructor(t,e){this._ref=e.decryptRef(t.ref),this._path=e.refToPath(this._ref),this._snap=t,this._crypto=e}get key(){return this._ref.key}get ref(){return new s(this._ref.ref,this._crypto)}val(){return this._crypto.transformValue(this._path,this._snap.val(),"decrypt")}child(t){return new e(this._snap.child(t),this._crypto)}forEach(t){return this._snap.forEach(r=>t(new e(r),this._crypto))}exists(){return this._snap.exists.apply(this._snap,arguments)}hasChild(t){return t=this._crypto.encryptPath(t.split("/"),this._crypto.specForPath(this._path)).join("/"),this._snap.hasChild(t)}hasChildren(){return this._snap.hasChildren.apply(this._snap,arguments)}numChildren(){return this._snap.numChildren.apply(this._snap,arguments)}toJSON(){const t=this._snap.toJSON.apply(this._snap,arguments);return this._crypto.transformValue(this._path,t,"decrypt")}}class r{constructor(t,e,r,i){this._query=t,this._order=e||{},this._originalRef=r||t,this._crypto=i}_wrapQueryCallback(t){if(!t||t.firecryptCallback)return;const r=(r,i)=>t.call(this,new e(r,this._crypto),i,this._crypto);r.firecryptCallback=r,t.firecryptCallback=r}get ref(){return new s(this._crypto.decryptRef(this._query.ref),this._crypto)}on(t,e,r,i){return this._wrapQueryCallback(e),this._originalRef.on.call(this._query,t,e.firecryptCallback,r,i)}off(t,e,r){return e&&e.firecryptCallback&&(e=e.firecryptCallback),this._originalRef.off.call(this._query,t,e,r)}once(t,r,i,n){return this._wrapQueryCallback(r),this._originalRef.once.call(this._query,t,r&&r.firecryptCallback,i,n).then(t=>new e(t,this._crypto))}orderByChild(t){return this._orderBy("orderByChild","child",t)}orderByKey(){return this._orderBy("orderByKey","key")}orderByValue(){return this._orderBy("orderByValue","value")}startAt(t,e){return this._checkCanSort(void 0!==e),this._delegate("startAt",arguments)}endAt(t,e){return this._checkCanSort(void 0!==e),this._delegate("endAt",arguments)}equalTo(t,e){return this._order[this._order.by+"Encrypted"]&&(t=this._crypto.encrypt(t,this._crypto.getType(t),this._order[this._order.by+"Encrypted"])),void 0!==e&&this._order.keyEncrypted&&(e=this._crypto.encrypt(e,"string",this._order.keyEncrypted)),new r(this._originalRef.equalTo.call(this._query,t,e),this._order,this._originalRef,this._crypto)}limitToFirst(){return this._delegate("limitToFirst",arguments)}limitToLast(){return this._delegate("limitToLast",arguments)}limit(){return this._delegate("limit",arguments)}_delegate(t,e){return new r(this._originalRef[t].apply(this._query,e),this._order,this._originalRef,this._crypto)}_checkCanSort(t){if("key"===this._order.by?this._order.keyEncrypted:this._order.valueEncrypted||t&&this._order.keyEncrypted)throw new Error("Encrypted items cannot be ordered")}_orderBy(t,e,i){const n=this._crypto.specForPath(this._crypto.refToPath(this.ref)),s={by:e};let o;if(n){const t=i&&i.split("/");for(const e in n){if(!n.hasOwnProperty(e))continue;const r=n[e];if(r[".encrypt"]&&(r[".encrypt"].key&&(s.keyEncrypted=r[".encrypt"].key),r[".encrypt"].value&&(s.valueEncrypted=r[".encrypt"].value)),i){const e=this._crypto.specForPath(t,r);e&&e[".encrypt"]&&e[".encrypt"].value&&(s.childEncrypted=e[".encrypt"].value);const n=this._crypto.encryptPath(t,r).join("/");if(o&&n!==o)throw new Error('Incompatible encryption specifications for orderByChild("'+i+'")');o=n}}}return new r(i?this._originalRef[t].call(this._query,o||i):this._originalRef[t].call(this._query),s,this._originalRef,this._crypto)}}class i{constructor(t,e,r){this._path=t,this._crypto=r,this._originalOnDisconnect=e}_interceptOnDisconnectWrite(t,e,r){const i=this;this[t]=function(){const n=Array.prototype.slice.call(e);return r>=0&&r<n.length&&(n[r]=i._crypto.transformValue(i._path,n[r],"encrypt")),i._originalOnDisconnect[t].apply(i._originalOnDisconnect,n)}}set(){return this._interceptOnDisconnectWrite("set",arguments,0)}update(){return this._interceptOnDisconnectWrite("update",arguments,0)}remove(){return this._interceptOnDisconnectWrite("remove",arguments)}cancel(){return this._interceptOnDisconnectWrite("cancel",arguments)}}let n;try{n=require("firebase-childrenkeys")}catch(t){}class s{constructor(t,e){this._ref=t,this._crypto=e}_interceptQuery(t,e){const i=this._crypto.encryptRef(this._ref),n=new r(i,{},this._ref,this._crypto);return n[t].apply(n,e)}_interceptWrite(t,e,r){const i=this._crypto.encryptRef(this._ref),n=Array.prototype.slice.call(e);if(r>=0&&r<n.length){const t=this._crypto.refToPath(this._ref);n[r]=this._crypto.transformValue(t,n[r],"encrypt")}return this._ref[t].apply(i,n)}static get SERVER_TIMESTAMP(){return{".sv":"timestamp"}}get key(){return this._ref.key}get path(){return decodeURIComponent(this._ref.toString()).slice(this._ref.root.toString().length-1)}get ref(){return this._ref.isEqual(this._ref.ref)?this:new s(this._ref.ref,this._crypto)}get root(){return this._ref.isEqual(this._ref.root)?this:new s(this._ref.root,this._crypto)}get parent(){return null===this._ref.parent?null:new s(this._ref.parent,this._crypto)}child(t){return new s(this._ref.child(t),this._crypto)}toJSON(){return this._ref.toJSON()}isEqual(t){return this._ref.isEqual(t._ref)}toString(){return decodeURIComponent(this._ref.toString())}push(){const t=this.child(this._ref.push().key);let e;return e=void 0===arguments[0]?Promise.resolve():t.set.apply(t,arguments),t.then=e.then.bind(e),t.catch=e.catch.bind(e),e.finally&&(t.finally=e.finally.bind(e)),t}set(){return this._interceptWrite("set",arguments,0)}remove(){return this._interceptWrite("remove",arguments)}update(){return this._interceptWrite("update",arguments,0)}childrenKeys(){const t=this._ref.childrenKeys||n;if("function"!=typeof t)throw new Error("childrenKeys() is not implemented. You must either provide a Firebase Database Reference\n        which implements childrenKeys() or npm install the firebase-children keys libary.");const e=this._crypto.encryptRef(this._ref);return t.apply(e,[e,...arguments]).then(t=>t.some(t=>/\x91/.test(t))?t.map(this._crypto.decrypt.bind(this._crypto)):t)}onDisconnect(){const t=this._crypto.encryptRef(this._ref);return new i(t,this._ref.onDisconnect.call(t),this._crypto)}on(){return this._interceptQuery("on",arguments)}off(){return this._interceptQuery("off",arguments)}once(){return this._interceptQuery("once",arguments)}orderByChild(){return this._interceptQuery("orderByChild",arguments)}orderByKey(){return this._interceptQuery("orderByKey",arguments)}orderByValue(){return this._interceptQuery("orderByValue",arguments)}startAt(){return this._interceptQuery("startAt",arguments)}endAt(){return this._interceptQuery("endAt",arguments)}equalTo(){return this._interceptQuery("equalTo",arguments)}limitToFirst(){return this._interceptQuery("limitToFirst",arguments)}limitToLast(){return this._interceptQuery("limitToLast",arguments)}transaction(){const t=this._crypto.encryptRef(this._ref),r=this._crypto.refToPath(this._ref),i=Array.prototype.slice.call(arguments),n=i[0];if(i[0]=n&&(t=>(t=this._crypto.transformValue(r,t,"decrypt"),t=n(t),t=this._crypto.transformValue(r,t,"encrypt"))),i.length>1){const t=i[1];i[1]=t&&((r,i,n)=>t(r,i,n&&new e(n,this._crypto)))}return this._ref.transaction.apply(t,i).then(t=>(t.snapshot=t.snapshot&&new e(t.snapshot,this._crypto),t))}}const o=e=>{const r=e.initializeApp;Object.defineProperty(e,"initializeApp",{value:function(){const i=r.apply(this,arguments),n=i.constructor.prototype.database;return Object.defineProperty(i.constructor.prototype,"database",{value:function(){const e=n.apply(this,arguments);return e.firecrypt||Object.defineProperty(e,"firecrypt",{value:new class{constructor(t){const e="object"==typeof t&&null!==t;if(!e||"object"!=typeof t.app||"function"!=typeof t.ref)throw new Error(`Expected first argument passed to FireCrypt constructor to be a Firebase Database instance, \n        but got "${t}".`);this._db=t,this._crypto=void 0}_ensureEncryptionConfigured(){if(void 0===this._crypto)throw new Error("Encryption for this FireCrypt reference has not been configured yet.")}_setupAesSiv(t,e){const r=CryptoJS.SIV.create(CryptoJS.enc.Base64.parse(t)),i=t=>CryptoJS.enc.Base64UrlSafe.stringify(r.encrypt(t)),n=t=>{const e=r.decrypt(CryptoJS.enc.Base64UrlSafe.parse(t));if(!1===e){const t=new Error("Wrong decryption key");throw t.firecrypt="WRONG_KEY",t}return CryptoJS.enc.Utf8.stringify(e)};return this._crypto.setStringEncryptionFunctions(i,n),e&&n(e),i(CryptoJS.enc.Base64UrlSafe.stringify(CryptoJS.lib.WordArray.random(10)))}get app(){return this._db.app}configureEncryption(e={},r={}){if("object"!=typeof e||null===e)throw new Error(`Expected second argument passed to configureEncryption() to be an object, but got "${e}".`);if("object"!=typeof r||null===r)throw new Error(`Expected third argument passed to configureEncryption() to be an object, but got "${r}".`);let i;switch(e.cacheSize=e.cacheSize||5e6,e.encryptionCacheSize=e.encryptionCacheSize||e.cacheSize,e.decryptionCacheSize=e.decryptionCacheSize||e.cacheSize,this._crypto=new t(e,r),e.algorithm){case"aes-siv":if(!e.key)throw new Error("You must specify a key to use AES encryption.");i=this._setupAesSiv(e.key,e.keyCheckValue);break;case"passthrough":this._crypto.setStringEncryptionFunctions(t=>t,t=>t);break;case"none":break;default:throw new Error('Unknown encryption algorithm "'+e.algorithm+'".')}return i}goOnline(){return this._ensureEncryptionConfigured(),this._db.goOnline()}goOffline(){return this._ensureEncryptionConfigured(),this._db.goOffline()}ref(t){if(this._ensureEncryptionConfigured(),void 0!==t&&"string"!=typeof t)throw new Error(`Expected first argument passed to ref() to be undefined or a string, but got "${t}".`);return new s(this._db.ref(t),this._crypto)}refFromURL(t){if(this._ensureEncryptionConfigured(),"string"!=typeof t||null===t.match(/^https:\/\/.*/g))throw new Error(`Expected first argument passed to refFromURL() to be a string URL, but got "${t}".`);return new s(this._db.refFromURL(path),this._crypto)}}(e)}),e.firecrypt}}),Object.defineProperty(e,"initializeApp",{value:r}),i},configurable:!0})};if("undefined"!=typeof require){"undefined"==typeof LRUCache&&(global.LRUCache=require("lru-cache")),"undefined"==typeof CryptoJS&&(global.CryptoJS=require("crypto-js/core")),require("crypto-js/enc-base64"),require("cryptojs-extension/build_node/siv"),o(require("firebase-admin"))}else{if("undefined"==typeof firebase)throw new Error("The Firebase web client SDK must be loaded before FireCrypt.");o(firebase)}CryptoJS.enc.Base64UrlSafe={stringify:CryptoJS.enc.Base64.stringify,parse:CryptoJS.enc.Base64.parse,_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}}();
//# sourceMappingURL=firecrypt.min.js.map
