{"version":3,"file":"firecrypt.min.js","sources":["src/crypto.js","src/FireCryptSnapshot.js","src/FireCryptQuery.js","src/FireCryptOnDisconnect.js","src/FireCryptReference.js","src/firecrypt.js"],"sourcesContent":["export default class Crypto {\n  constructor(options, spec) {\n    this._spec = this._cleanSpecification(spec);\n    this._encryptString = this._throwNotSetUpError;\n    this._decryptString = this._throwNotSetUpError;\n\n    this._patternRegexes = {};\n\n    if (typeof LRUCache === 'function') {\n      this._encryptionCache = new LRUCache({\n        max: options.encryptionCacheSize,\n        length: this._computeCacheItemSize,\n      });\n      this._decryptionCache = new LRUCache({\n        max: options.decryptionCacheSize,\n        length: this._computeCacheItemSize,\n      });\n    }\n  }\n\n  _cleanSpecification(def, path) {\n    var keys = Object.keys(def);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      if (key === '.encrypt') {\n        var encryptKeys = Object.keys(def[key]);\n        for (var j = 0; j < encryptKeys.length; j++) {\n          var encryptKey = encryptKeys[j];\n          if (encryptKey !== 'key' && encryptKey !== 'value' && encryptKey !== 'few') {\n            throw new Error('Illegal .encrypt subkey: ' + encryptKeys[j]);\n          }\n        }\n      } else {\n        if (/[\\x00-\\x1f\\x7f\\x91\\x92\\.#\\[\\]/]/.test(key) || /[$]/.test(key.slice(1))) {\n          throw new Error('Illegal character in specification key: ' + key);\n        }\n        this._cleanSpecification(def[key], (path || '') + '/' + key);\n      }\n      switch (key.charAt(0)) {\n        case '$':\n          if (key === '$') break;\n          if (def.$) throw new Error('Multiple wildcard keys in specification at ' + path);\n          def.$ = def[key];\n          delete def[key];\n          break;\n        case '.':\n          if (key !== '.encrypt') throw new Error('Unknown directive at ' + path + ': ' + key);\n          break;\n      }\n    }\n    return def;\n  }\n\n  _throwNotSetUpError() {\n    var e = new Error('Encryption not set up');\n    e.firecrypt = 'NO_KEY';\n    throw e;\n  }\n\n  _computeCacheItemSize(value, key) {\n    return key.length + (typeof value === 'string' ? value.length : 4);\n  }\n\n  setStringEncryptionFunctions(encryptString, decryptString) {\n    this._encryptString = encryptString;\n    this._decryptString = decryptString;\n  }\n\n  encryptPath(path, def) {\n    def = def || this._spec.rules;\n    path = path.slice();\n    for (var i = 0; i < path.length; i++) {\n      def = def[path[i]] || def.$;\n      if (!def) break;\n      if (def['.encrypt'] && def['.encrypt'].key) {\n        path[i] = this.encrypt(path[i], 'string', def['.encrypt'].key);\n      }\n    }\n    return path;\n  }\n\n  encryptRef(ref, path) {\n    var encryptedPath = this.encryptPath(path || this.refToPath(ref));\n    return encryptedPath.length ? ref.root.child(encryptedPath.join('/')) : ref.root;\n  }\n\n  decryptRef(ref) {\n    var path = this.refToPath(ref, true);\n    var changed = false;\n    for (var i = 0; i < path.length; i++) {\n      var decryptedPathSegment = this.decrypt(path[i]);\n      if (decryptedPathSegment !== path[i]) {\n        path[i] = decryptedPathSegment;\n        changed = true;\n      }\n    }\n    return changed ? ref.root.child(path.join('/')) : ref;\n  }\n\n  specForPath(path, def) {\n    def = def || this._spec.rules;\n    for (var i = 0; def && i < path.length; i++) {\n      def = def[path[i]] || def.$;\n    }\n    return def;\n  }\n\n  transformValue(path, value, transformType) {\n    if (transformType !== 'encrypt' && transformType !== 'decrypt') {\n      throw new Error(\n        `Transform type must be either \"encrypt\" or \"decrypt\", but got \"${transformType}\".`\n      );\n    }\n    const transform = transformType === 'encrypt' ? this.encrypt.bind(this) : this.decrypt.bind(this);\n    return this.transformTree(value, this.specForPath(path), transform);\n  }\n\n  transformTree(value, def, transform) {\n    if (!def) return value;\n    var type = this.getType(value);\n    var i;\n    if (/^(string|number|boolean)$/.test(type)) {\n      if (def['.encrypt'] && def['.encrypt'].value) {\n        value = transform(value, type, def['.encrypt'].value);\n      }\n    } else if (type === 'object' && value !== null) {\n      var transformedValue = {};\n      for (var key in value) {\n        if (!value.hasOwnProperty(key)) continue;\n        var subValue = value[key], subDef;\n        if (key.indexOf('/') >= 0) {  // for deep update keys\n          var keyParts = key.split('/');\n          subDef = def;\n          for (i = 0; i < keyParts.length; i++) {\n            if (transform === this.decrypt) {\n              keyParts[i] = this.decrypt(keyParts[i]);\n              subDef = subDef && (subDef[keyParts[i]] || subDef.$);\n            } else {\n              subDef = subDef && (subDef[keyParts[i]] || subDef.$);\n              if (subDef && subDef['.encrypt'] && subDef['.encrypt'].key) {\n                keyParts[i] = transform(keyParts[i], 'string', subDef['.encrypt'].key);\n              }\n            }\n          }\n          key = keyParts.join('/');\n        } else {\n          if (transform === this.decrypt) {\n            key = this.decrypt(key);\n            subDef = def[key] || def.$;\n          } else {\n            subDef = def[key] || def.$;\n            if (subDef && subDef['.encrypt'] && subDef['.encrypt'].key) {\n              key = transform(key, 'string', subDef['.encrypt'].key);\n            }\n          }\n        }\n        transformedValue[key] = this.transformTree(subValue, subDef, transform);\n      }\n      value = transformedValue;\n    } else if (type === 'array') {\n      if (!def.$) return value;\n      for (i = 0; i < value.length; i++) value[i] = this.transformTree(value[i], def.$, transform);\n    }\n    return value;\n  }\n\n  refToPath(ref, encrypted) {\n    var root = ref.root;\n    if (ref === root) return [];\n    var pathStr = decodeURIComponent(ref.toString().slice(root.toString().length));\n    if (!encrypted && pathStr && pathStr.charAt(0) !== '.' &&\n        /[\\x00-\\x1f\\x7f\\x91\\x92\\.#$\\[\\]]/.test(pathStr)) {\n      throw new Error('Path contains invalid characters: ' + pathStr);\n    }\n    return pathStr.split('/');\n  }\n\n  encrypt(value, type, pattern) {\n    var cacheKey;\n    if (this._encryptionCache) {\n      cacheKey = type.charAt(0) + pattern + '\\x91' + value;\n      if (this._encryptionCache.has(cacheKey)) return this._encryptionCache.get(cacheKey);\n    }\n    var result;\n    if (pattern === '#') {\n      result = this.encryptValue(value, type);\n    } else {\n      if (type !== 'string') {\n        throw new Error('Can\\'t encrypt a ' + type + ' using pattern [' + pattern + ']');\n      }\n      var match = value.match(this.compilePattern(pattern));\n      if (!match) {\n        throw new Error(\n          'Can\\'t encrypt as value doesn\\'t match pattern [' + pattern + ']: ' + value);\n      }\n      var i = 0;\n      result = pattern.replace(/[#\\.]/g, (placeholder) => {\n        var part = match[++i];\n        if (placeholder === '#') part = this.encryptValue(part, 'string');\n        return part;\n      });\n    }\n    if (this._encryptionCache) this._encryptionCache.set(cacheKey, result);\n    return result;\n  }\n\n  encryptValue(value, type) {\n    if (!/^(string|number|boolean)$/.test(type)) throw new Error('Can\\'t encrypt a ' + type);\n    switch (type) {\n      case 'number': value = '' + value; break;\n      case 'boolean': value = value ? 't' : 'f'; break;\n    }\n    return '\\x91' + type.charAt(0).toUpperCase() + this._encryptString(value) + '\\x92';\n  }\n\n  decrypt(value) {\n    if (this._decryptionCache && this._decryptionCache.has(value)) return this._decryptionCache.get(value);\n    if (!/\\x91/.test(value)) return value;\n    var result;\n    var match = value.match(/^\\x91(.)([^\\x92]*)\\x92$/);\n    if (match) {\n      var decryptedString = this._decryptString(match[2]);\n      switch (match[1]) {\n        case 'S':\n          result = decryptedString;\n          break;\n        case 'N':\n          result = Number(decryptedString);\n          // Check for NaN, since it's the only value where x !== x.\n          if (result !== result) throw new Error('Invalid encrypted number: ' + decryptedString);\n          break;\n        case 'B':\n          if (decryptedString === 't') result = true;\n          else if (decryptedString === 'f') result = false;\n          else throw new Error('Invalid encrypted boolean: ' + decryptedString);\n          break;\n        default:\n          throw new Error('Invalid encrypted value type code: ' + match[1]);\n      }\n    } else {\n      result = value.replace(/\\x91(.)([^\\x92]*)\\x92/g, (match, typeCode, encryptedString) => {\n        if (typeCode !== 'S') throw new Error('Invalid multi-segment encrypted value: ' + typeCode);\n        return this._decryptString(encryptedString);\n      });\n    }\n    if (this._decryptionCache) this._decryptionCache.set(value, result);\n    return result;\n  }\n\n  getType(value) {\n    if (Array.isArray(value)) return 'array';\n    var type = typeof value;\n    if (type === 'object') {\n      if (value instanceof String) type = 'string';\n      else if (value instanceof Number) type = 'number';\n      else if (value instanceof Boolean) type = 'boolean';\n    }\n    return type;\n  }\n\n  compilePattern(pattern) {\n    var regex = this._patternRegexes[pattern];\n    if (!regex) {\n      regex = this._patternRegexes[pattern] = new RegExp('^' + pattern\n        .replace(/\\./g, '#')\n        .replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')  // escape regex chars\n        .replace(/#/g, '(.*?)') + '$');\n    }\n    return regex;\n  }\n}\n","import FireCryptReference from './FireCryptReference';\n\nexport default class FireCryptSnapshot {\n  constructor(snap, crypto) {\n    this._ref = crypto.decryptRef(snap.ref);\n    this._path = crypto.refToPath(this._ref);\n    this._snap = snap;\n    this._crypto = crypto;\n\n  }\n\n  get key() {\n    return this._ref.key;\n  }\n\n  get ref() {\n    return new FireCryptReference(this._ref.ref, this._crypto);\n  }\n\n  val() {\n    return this._crypto.transformValue(this._path, this._snap.val(), 'decrypt');\n  }\n\n  child(childPath) {\n    return new FireCryptSnapshot(this._snap.child(childPath), this._crypto);\n  }\n\n  forEach(action) {\n    return this._snap.forEach((childSnap) => {\n      return action(new FireCryptSnapshot(childSnap), this._crypto);\n    });\n  }\n\n  exists() {\n    return this._snap.exists.apply(this._snap, arguments)\n  }\n\n  hasChild(childPath) {\n    childPath = this._crypto.encryptPath(childPath.split('/'), this._crypto.specForPath(this._path)).join('/');\n    return this._snap.hasChild(childPath);\n  }\n\n  hasChildren() {\n    return this._snap.hasChildren.apply(this._snap, arguments)\n  }\n\n  numChildren() {\n    return this._snap.numChildren.apply(this._snap, arguments)\n  }\n\n  toJSON() {\n    const json = this._snap.toJSON.apply(this._snap, arguments);\n    return this._crypto.transformValue(this._path, json, 'decrypt');\n  }\n}\n","import FireCryptSnapshot from './FireCryptSnapshot';\nimport FireCryptReference from './FireCryptReference';\n\nexport default class FireCryptQuery {\n  constructor(query, order, originalRef, crypto) {\n    this._query = query;\n    this._order = order || {};\n    this._originalRef = originalRef || query;\n    this._crypto = crypto;\n  }\n\n  _wrapQueryCallback(callback) {\n    if (!callback || callback.firecryptCallback) return;\n    const self = this;\n    const wrappedCallback = function (snap, previousChildKey) {\n      return callback.call(this, new FireCryptSnapshot(snap, self._crypto), previousChildKey, self._crypto);\n    };\n    wrappedCallback.firecryptCallback = wrappedCallback;\n    callback.firecryptCallback = wrappedCallback;\n  }\n\n  get ref() {\n    return new FireCryptReference(this._crypto.decryptRef(this._query.ref), this._crypto);\n  }\n\n  on(eventType, callback, cancelCallback, context) {\n    this._wrapQueryCallback(callback);\n    return this._originalRef.on.call(\n      this._query, eventType, callback.firecryptCallback, cancelCallback, context);\n  }\n\n  off(eventType, callback, context) {\n    if (callback && callback.firecryptCallback) callback = callback.firecryptCallback;\n    return this._originalRef.off.call(this._query, eventType, callback, context);\n  }\n\n  once(eventType, successCallback, failureCallback, context) {\n    this._wrapQueryCallback(successCallback);\n    return this._originalRef.once.call(\n      this._query, eventType, successCallback && successCallback.firecryptCallback, failureCallback,\n      context\n    ).then((snap) => {\n      return new FireCryptSnapshot(snap, this._crypto);\n    });\n  }\n  \n  orderByChild(key) {\n    return this._orderBy('orderByChild', 'child', key);\n  }\n\n  orderByKey() {\n    return this._orderBy('orderByKey', 'key');\n  }\n\n  orderByValue() {\n    return this._orderBy('orderByValue', 'value');\n  }\n\n  startAt(value, key) {\n    this._checkCanSort(key !== undefined);\n    return this._delegate('startAt', arguments);\n  }\n\n  endAt(value, key) {\n    this._checkCanSort(key !== undefined);\n    return this._delegate('endAt', arguments);\n  }\n\n  equalTo(value, key) {\n    if (this._order[this._order.by + 'Encrypted']) {\n      value = this._crypto.encrypt(value, this._crypto.getType(value), this._order[this._order.by + 'Encrypted']);\n    }\n    if (key !== undefined && this._order.keyEncrypted) {\n      key = this._crypto.encrypt(key, 'string', this._order.keyEncrypted);\n    }\n    return new FireCryptQuery(this._originalRef.equalTo.call(this._query, value, key), this._order, this._originalRef, this._crypto);\n  }\n\n  limitToFirst() {\n    return this._delegate('limitToFirst', arguments);\n  }\n\n  limitToLast() {\n    return this._delegate('limitToLast', arguments);\n  }\n\n  _delegate(methodName, args) {\n    return new FireCryptQuery(this._originalRef[methodName].apply(this._query, args), this._order, this._originalRef, this._crypto);\n  }\n\n  _checkCanSort(hasExtraKey) {\n    if (this._order.by === 'key' ?\n        this._order.keyEncrypted :\n        this._order.valueEncrypted || hasExtraKey && this._order.keyEncrypted) {\n      throw new Error('Encrypted items cannot be ordered');\n    }\n  }\n\n  _orderBy(methodName, by, childKey) {\n    const def = this._crypto.specForPath(this._crypto.refToPath(this.ref));\n    const order = {by: by}\n\n    let encryptedChildKey;\n    if (def) {\n      const childPath = childKey && childKey.split('/');\n      for (const subKey in def) {\n        if (!def.hasOwnProperty(subKey)) continue;\n        const subDef = def[subKey];\n        if (subDef['.encrypt']) {\n          if (subDef['.encrypt'].key) order.keyEncrypted = subDef['.encrypt'].key;\n          if (subDef['.encrypt'].value) order.valueEncrypted = subDef['.encrypt'].value;\n        }\n        if (childKey) {\n          const childDef = this._crypto.specForPath(childPath, subDef);\n          if (childDef && childDef['.encrypt'] && childDef['.encrypt'].value) {\n            order.childEncrypted = childDef['.encrypt'].value;\n          }\n          const encryptedChildKeyCandidate = this._crypto.encryptPath(childPath, subDef).join('/');\n          if (encryptedChildKey && encryptedChildKeyCandidate !== encryptedChildKey) {\n            throw new Error(\n              'Incompatible encryption specifications for orderByChild(\"' + childKey + '\")');\n          }\n          encryptedChildKey = encryptedChildKeyCandidate;\n        }\n      }\n    }\n    if (childKey) {\n      return new FireCryptQuery(\n        this._originalRef[methodName].call(this._query, encryptedChildKey || childKey), order, this._originalRef, this._crypto);\n    } else {\n      return new FireCryptQuery(this._originalRef[methodName].call(this._query), order, this._originalRef, this._crypto);\n    }\n  }\n}\n","export default class FireCryptOnDisconnect {\n  constructor(path, originalOnDisconnect, crypto) {\n    this._path = path;\n    this._crypto = crypto;\n    this._originalOnDisconnect = originalOnDisconnect;\n  }\n\n  _interceptOnDisconnectWrite(methodName, originalArguments, argIndex) {\n    const self = this;\n\n    this[methodName] = function() {\n      const args = Array.prototype.slice.call(originalArguments);\n      if (argIndex >= 0 && argIndex < args.length) {\n        args[argIndex] = self._crypto.transformValue(self._path, args[argIndex], 'encrypt');\n      }\n\n      return self._originalOnDisconnect[methodName].apply(self._originalOnDisconnect, args);\n    };\n  }\n\n  set() {\n    return this._interceptOnDisconnectWrite('set', arguments, 0);\n  }\n\n  update() {\n    return this._interceptOnDisconnectWrite('update', arguments, 0);\n  }\n\n  remove() {\n    return this._interceptOnDisconnectWrite('remove', arguments);\n  }\n\n  cancel() {\n    return this._interceptOnDisconnectWrite('cancel', arguments);\n  }\n}\n","import FireCryptQuery from './FireCryptQuery';\nimport FireCryptSnapshot from './FireCryptSnapshot';\nimport FireCryptOnDisconnect from './FireCryptOnDisconnect';\n\nlet childrenKeysFromLib;\ntry {\n  childrenKeysFromLib = require('firebase-childrenkeys');\n} catch (e) {\n  // Library is optional, so ignore any errors from failure to load it.\n}\n\nexport default class FireCryptReference {\n  constructor(ref, crypto) {\n    this._ref = ref;\n    this._crypto = crypto;\n  }\n\n  _interceptQuery(methodName, originalArguments) {\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n    const query = new FireCryptQuery(encryptedRef, {}, this._ref, this._crypto);\n    return query[methodName].apply(query, originalArguments);\n  }\n\n  _interceptWrite(methodName, originalArguments, argIndex) {\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n\n    const args = Array.prototype.slice.call(originalArguments);\n    if (argIndex >= 0 && argIndex < args.length) {\n      const path = this._crypto.refToPath(this._ref);\n      args[argIndex] = this._crypto.transformValue(path, args[argIndex], 'encrypt');\n    }\n\n    return this._ref[methodName].apply(encryptedRef, args);\n  }\n\n  /**\n   * Returns a placeholder value for auto-populating the current timestamp (time since the Unix\n   * epoch, in milliseconds) as determined by the Firebase servers.\n   * @return {Object} A timestamp placeholder value.\n   */\n  static get SERVER_TIMESTAMP() {\n    return {\n      '.sv': 'timestamp'\n    };\n  }\n\n  /**\n   * Returns the last part of this reference's path. The key of a root reference is `null`.\n   * @return {string|null} The last part this reference's path.\n   */\n  get key() {\n    return this._ref.key;\n  }\n\n  /**\n   * Returns just the path component of the reference's URL.\n   * @return {string} The path component of the Firebase URL wrapped by this reference.\n   */\n  get path() {\n    return decodeURIComponent(this._ref.toString()).slice(this._ref.root.toString().length - 1);\n  }\n\n  /**\n   * Returns a FireCryptReference at the same location as this query or reference.\n   * @return {FireCryptReference|null} A FireCryptReference at the same location as this query or\n   *     reference.\n   */\n  get ref() {\n    if (this._ref.isEqual(this._ref.ref)) {\n      return this;\n    } else {\n      return new FireCryptReference(this._ref.ref, this._crypto);\n    }\n  }\n\n  /**\n   * Returns a FireCryptReference reference to the root of the database.\n   * @return {FireCryptReference} The root reference of the database.\n   */\n  get root() {\n    if (this._ref.isEqual(this._ref.root)) {\n      return this;\n    } else {\n      return new FireCryptReference(this._ref.root, this._crypto);\n    }\n  }\n\n  /**\n   * Returns a FireCryptReference to the parent location of this reference. The parent of a root\n   * reference is `null`.\n   * @return {FireCryptReference|null} The parent location of this reference.\n   */\n  get parent() {\n    if (this._ref.parent === null) {\n      return null;\n    } else {\n      return new FireCryptReference(this._ref.parent, this._crypto);\n    }\n  }\n\n  /**\n   * Returns the FireCrypt instance associated with this reference.\n   * @return {FireCrypt} The FireCrypt instance associated with this reference.\n   */\n  get database() {\n    return this._ref.ref.database.firecrypt;\n  }\n\n  /**\n   * Creates a new FireCryptReference object on a child of this one.\n   * @param  {string} path The path to the desired child, relative to this reference.\n   * @return {FireCryptReference} The child reference.\n   */\n  child(path) {\n    return new FireCryptReference(this._ref.child(path), this._crypto);\n  }\n\n  /**\n   * Returns a JSON-serializable representation of this object.\n   * @return {Object} A JSON-serializable representation of this object.\n   */\n  toJSON() {\n    return this._ref.toJSON();\n  }\n\n  /**\n   * Returns whether or not this FireCryptReference is equivalent to the provided FireCryptReference.\n   * @return {FireCryptReference} Another FireCryptReference instance against which to compare.\n   */\n  isEqual(otherRef) {\n    return this._ref.isEqual(otherRef._ref);\n  }\n\n  /**\n   * Stringifies the wrapped reference.\n   * @return {string} The Firebase URL wrapped by this FireCryptReference object.\n   */\n  toString() {\n    return decodeURIComponent(this._ref.toString());\n  }\n\n  push() {\n    const pushedRef = this.child(this._ref.push().key);\n\n    let promise;\n    if (typeof arguments[0] === 'undefined') {\n      // A bare pushed ref should also be thennable.\n      promise = Promise.resolve();\n    } else {\n      promise = pushedRef.set.apply(pushedRef, arguments);\n    }\n\n    pushedRef.then = promise.then.bind(promise);\n    pushedRef.catch = promise.catch.bind(promise);\n    if (promise.finally) pushedRef.finally = promise.finally.bind(promise);\n\n    return pushedRef;\n  }\n\n  set() {\n    return this._interceptWrite('set', arguments, 0);\n  }\n\n  remove() {\n    return this._interceptWrite('remove', arguments);\n  }\n\n  update() {\n    return this._interceptWrite('update', arguments, 0);\n  }\n\n  childrenKeys() {\n    const originalMethod = this._ref.childrenKeys || childrenKeysFromLib;\n\n    if (typeof originalMethod !== 'function') {\n      throw new Error(\n        `childrenKeys() is not implemented. You must either provide a Firebase Database Reference\n        which implements childrenKeys() or npm install the firebase-children keys libary.`\n      );\n    }\n\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n    return originalMethod.apply(encryptedRef, [encryptedRef, ...arguments]).then((keys) => {\n      if (!keys.some((key) => /\\x91/.test(key))) {\n        return keys;\n      }\n      return keys.map(this._crypto.decrypt.bind(this._crypto));\n    });\n  }\n\n  onDisconnect() {\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n    return new FireCryptOnDisconnect(encryptedRef, this._ref.onDisconnect.call(encryptedRef), this._crypto);\n  }\n\n  on() {\n    return this._interceptQuery('on', arguments);\n  }\n\n  off() {\n    return this._interceptQuery('off', arguments);\n  }\n\n  once() {\n    return this._interceptQuery('once', arguments);\n  }\n\n  orderByChild() {\n    return this._interceptQuery('orderByChild', arguments);\n  }\n\n  orderByKey() {\n    return this._interceptQuery('orderByKey', arguments);\n  }\n\n  orderByValue() {\n    return this._interceptQuery('orderByValue', arguments);\n  }\n\n  startAt() {\n    return this._interceptQuery('startAt', arguments);\n  }\n\n  endAt() {\n    return this._interceptQuery('endAt', arguments);\n  }\n\n  equalTo() {\n    return this._interceptQuery('equalTo', arguments);\n  }\n\n  limitToFirst() {\n    return this._interceptQuery('limitToFirst', arguments);\n  }\n\n  limitToLast() {\n    return this._interceptQuery('limitToLast', arguments);\n  }\n\n  transaction() {\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n    const path = this._crypto.refToPath(this._ref);\n\n    const args = Array.prototype.slice.call(arguments);\n    const originalCompute = args[0];\n    args[0] = originalCompute && ((value) => {\n      value = this._crypto.transformValue(path, value, 'decrypt');\n      value = originalCompute(value);\n      value = this._crypto.transformValue(path, value, 'encrypt');\n      return value;\n    });\n    if (args.length > 1) {\n      const originalOnComplete = args[1];\n      args[1] = originalOnComplete && ((error, committed, snapshot) => {\n        return originalOnComplete(error, committed, snapshot && new FireCryptSnapshot(snapshot, this._crypto));\n      });\n    }\n    return this._ref.transaction.apply(encryptedRef, args).then((result) => {\n      result.snapshot = result.snapshot && new FireCryptSnapshot(result.snapshot, this._crypto);\n      return result;\n    });\n  };\n}\n","const patchFirebaseDatabaseApi = (fb) => {\n  // We want to wrap all instances of the Firebase database() with FireCrypt.  These are always\n  // eventually instantiated via an App's database() function, so we'd like to override that.\n  // However, we can't get at the App prototype directly so instead we patch initializeApp(),\n  // which must be called for an app instance to become available, and patch the App prototype\n  // on the first call.  Once the prototype is patched, we can restore the original initializeApp.\n  const originalInitializeApp = fb.initializeApp;\n  Object.defineProperty(fb, 'initializeApp', {value: function() {\n    const app = originalInitializeApp.apply(this, arguments);\n    const originalDatabase = app.constructor.prototype.database;\n    Object.defineProperty(app.constructor.prototype, 'database', {value: function() {\n      // The database() call caches databases by URL and can return the same instance on separate\n      // calls.  Ensure that there's a 1-to-1 correspondance between database instances and\n      // FireCrypt wrappers by associating a wrapper with its underlying database.\n      const db = originalDatabase.apply(this, arguments);\n      if (!db.firecrypt) {\n        Object.defineProperty(db, 'firecrypt', {value: new FireCrypt(db)});\n      }\n      return db.firecrypt;\n    }});\n    Object.defineProperty(fb, 'initializeApp', {value: originalInitializeApp});\n    return app;\n  }, configurable: true})\n}\n\nif (typeof require !== 'undefined') {\n  if (typeof LRUCache === 'undefined') global.LRUCache = require('lru-cache');\n  if (typeof CryptoJS === 'undefined') global.CryptoJS = require('crypto-js/core');\n  require('crypto-js/enc-base64');\n  require('cryptojs-extension/build_node/siv');\n  const admin = require('firebase-admin');\n  patchFirebaseDatabaseApi(admin);\n} else if (typeof firebase !== 'undefined') {\n  patchFirebaseDatabaseApi(firebase);\n} else {\n  throw new Error('The Firebase web client SDK must be loaded before FireCrypt.')\n}\n\nCryptoJS.enc.Base64UrlSafe = {\n  stringify: CryptoJS.enc.Base64.stringify,\n  parse: CryptoJS.enc.Base64.parse,\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n};\n\nimport Crypto from './crypto';\nimport FireCryptReference from './FireCryptReference';\n\nclass FireCrypt {\n  constructor(db) {\n    const dbIsNonNullObject = typeof db === 'object' && db !== null;\n    if (!dbIsNonNullObject || typeof db.app !== 'object' || typeof db.ref !== 'function') {\n      throw new Error(\n        `Expected first argument passed to FireCrypt constructor to be a Firebase Database instance, \n        but got \"${db}\".`\n      );\n    }\n\n    this._db = db;\n    this._crypto = undefined;\n  }\n\n  _ensureEncryptionConfigured() {\n    if (typeof this._crypto === 'undefined') {\n      throw new Error('Encryption for this FireCrypt reference has not been configured yet.');\n    }\n  }\n\n  _setupAesSiv(key, checkValue) {\n    const siv = CryptoJS.SIV.create(CryptoJS.enc.Base64.parse(key));\n    const encryptString = (str) => {\n      return CryptoJS.enc.Base64UrlSafe.stringify(siv.encrypt(str));\n    };\n    const decryptString = (str) => {\n      const result = siv.decrypt(CryptoJS.enc.Base64UrlSafe.parse(str));\n      if (result === false) {\n        const e = new Error('Wrong decryption key');\n        e.firecrypt = 'WRONG_KEY';\n        throw e;\n      }\n      return CryptoJS.enc.Utf8.stringify(result);\n    };\n  \n    this._crypto.setStringEncryptionFunctions(encryptString, decryptString);\n  \n    if (checkValue) decryptString(checkValue);\n    return encryptString(CryptoJS.enc.Base64UrlSafe.stringify(CryptoJS.lib.WordArray.random(10)));\n  }\n\n  get app() {\n    return this._db.app;\n  }\n\n  configureEncryption(options = {}, specification = {}) {\n    if (typeof options !== 'object' || options === null) {\n      throw new Error(\n        `Expected second argument passed to configureEncryption() to be an object, but got \"${options}\".`\n      );\n    } else if (typeof specification !== 'object' || specification === null) {\n      throw new Error(\n        `Expected third argument passed to configureEncryption() to be an object, but got \"${specification}\".`\n      );\n    }\n\n    options.cacheSize = options.cacheSize || 5 * 1000 * 1000;\n    options.encryptionCacheSize = options.encryptionCacheSize || options.cacheSize;\n    options.decryptionCacheSize = options.decryptionCacheSize || options.cacheSize;\n\n    this._crypto = new Crypto(options, specification);\n\n    let result;\n\n    switch (options.algorithm) {\n      case 'aes-siv':\n        if (!options.key) throw new Error('You must specify a key to use AES encryption.');\n        result = this._setupAesSiv(options.key, options.keyCheckValue);\n        break;\n      case 'passthrough':\n        this._crypto.setStringEncryptionFunctions((str) => str, (str) => str);\n        break;\n      case 'none':\n        break;\n      default:\n        throw new Error('Unknown encryption algorithm \"' + options.algorithm + '\".');\n    }\n\n    // Make the encryption key check value available off of this FireCrypt instance and therefore\n    // off of admin.database().\n    this.encryptionKeyCheckValue = result;\n\n    return result;\n  }\n\n  goOnline() {\n    this._ensureEncryptionConfigured();\n    return this._db.goOnline();\n  }\n\n  goOffline() {\n    this._ensureEncryptionConfigured();\n    return this._db.goOffline();\n  }\n\n  ref(path) {\n    this._ensureEncryptionConfigured();\n\n    if (typeof path !== 'undefined' && typeof path !== 'string') {\n      throw new Error(\n        `Expected first argument passed to ref() to be undefined or a string, but got \"${path}\".`\n      );\n    }\n\n    return new FireCryptReference(this._db.ref(path), this._crypto);\n  }\n\n  refFromURL(url) {\n    this._ensureEncryptionConfigured();\n\n    if (typeof url !== 'string' || url.match(/^https:\\/\\/.*/g) === null) {\n      throw new Error(\n        `Expected first argument passed to refFromURL() to be a string URL, but got \"${url}\".`\n      );\n    }\n\n    return new FireCryptReference(this._db.refFromURL(path), this._crypto);\n  }\n}\n"],"names":["Crypto","options","spec","_spec","this","_cleanSpecification","_encryptString","_throwNotSetUpError","_decryptString","_patternRegexes","LRUCache","_encryptionCache","encryptionCacheSize","_computeCacheItemSize","_decryptionCache","decryptionCacheSize","def","path","keys","Object","i","length","key","encryptKeys","j","encryptKey","Error","test","slice","charAt","$","e","firecrypt","value","encryptString","decryptString","rules","encrypt","ref","encryptedPath","encryptPath","refToPath","root","child","join","changed","decryptedPathSegment","decrypt","transformType","transform","bind","transformTree","specForPath","type","getType","transformedValue","hasOwnProperty","subDef","subValue","indexOf","keyParts","split","encrypted","pathStr","decodeURIComponent","toString","pattern","cacheKey","result","has","get","encryptValue","match","compilePattern","replace","placeholder","part","set","toUpperCase","decryptedString","Number","typeCode","encryptedString","Array","isArray","String","Boolean","regex","RegExp","FireCryptSnapshot","snap","crypto","_ref","decryptRef","_path","_snap","_crypto","FireCryptReference","transformValue","val","childPath","action","forEach","childSnap","exists","apply","arguments","hasChild","hasChildren","numChildren","json","toJSON","FireCryptQuery","query","order","originalRef","_query","_order","_originalRef","callback","firecryptCallback","self","wrappedCallback","previousChildKey","call","eventType","cancelCallback","context","_wrapQueryCallback","on","off","successCallback","failureCallback","once","then","_orderBy","_checkCanSort","undefined","_delegate","by","keyEncrypted","equalTo","methodName","args","hasExtraKey","valueEncrypted","childKey","encryptedChildKey","subKey","childDef","childEncrypted","encryptedChildKeyCandidate","FireCryptOnDisconnect","originalOnDisconnect","_originalOnDisconnect","originalArguments","argIndex","prototype","_interceptOnDisconnectWrite","childrenKeysFromLib","require","encryptedRef","encryptRef","isEqual","parent","database","otherRef","pushedRef","push","promise","Promise","resolve","catch","finally","_interceptWrite","originalMethod","childrenKeys","some","map","onDisconnect","_interceptQuery","originalCompute","originalOnComplete","error","committed","snapshot","transaction","patchFirebaseDatabaseApi","fb","originalInitializeApp","initializeApp","defineProperty","app","originalDatabase","constructor","db","dbIsNonNullObject","_db","checkValue","siv","CryptoJS","SIV","create","enc","Base64","parse","str","Base64UrlSafe","stringify","Utf8","setStringEncryptionFunctions","lib","WordArray","random","specification","cacheSize","algorithm","_setupAesSiv","keyCheckValue","encryptionKeyCheckValue","_ensureEncryptionConfigured","goOnline","goOffline","url","refFromURL","configurable","global","firebase"],"mappings":"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"}