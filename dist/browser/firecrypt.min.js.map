{"version":3,"file":"firecrypt.min.js","sources":["src/crypto.js","src/FireCryptSnapshot.js","src/FireCryptQuery.js","src/FireCryptOnDisconnect.js","src/FireCryptReference.js","src/firecrypt.js"],"sourcesContent":["export default class Crypto {\n  constructor(options, spec) {\n    this._spec = this._cleanSpecification(spec);\n    this._encryptString = this._throwNotSetUpError;\n    this._decryptString = this._throwNotSetUpError;\n\n    this._patternRegexes = {};\n\n    if (typeof LRUCache === 'function') {\n      this._encryptionCache = new LRUCache({\n        max: options.encryptionCacheSize,\n        length: this._computeCacheItemSize,\n      });\n      this._decryptionCache = new LRUCache({\n        max: options.decryptionCacheSize,\n        length: this._computeCacheItemSize,\n      });\n    }\n  }\n\n  _cleanSpecification(def, path) {\n    var keys = Object.keys(def);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      if (key === '.encrypt') {\n        var encryptKeys = Object.keys(def[key]);\n        for (var j = 0; j < encryptKeys.length; j++) {\n          var encryptKey = encryptKeys[j];\n          if (encryptKey !== 'key' && encryptKey !== 'value' && encryptKey !== 'few') {\n            throw new Error('Illegal .encrypt subkey: ' + encryptKeys[j]);\n          }\n        }\n      } else {\n        if (/[\\x00-\\x1f\\x7f\\x91\\x92\\.#\\[\\]/]/.test(key) || /[$]/.test(key.slice(1))) {\n          throw new Error('Illegal character in specification key: ' + key);\n        }\n        this._cleanSpecification(def[key], (path || '') + '/' + key);\n      }\n      switch (key.charAt(0)) {\n        case '$':\n          if (key === '$') break;\n          if (def.$) throw new Error('Multiple wildcard keys in specification at ' + path);\n          def.$ = def[key];\n          delete def[key];\n          break;\n        case '.':\n          if (key !== '.encrypt') throw new Error('Unknown directive at ' + path + ': ' + key);\n          break;\n      }\n    }\n    return def;\n  }\n\n  _throwNotSetUpError() {\n    var e = new Error('Encryption not set up');\n    e.firecrypt = 'NO_KEY';\n    throw e;\n  }\n\n  _computeCacheItemSize(value, key) {\n    return key.length + (typeof value === 'string' ? value.length : 4);\n  }\n\n  setStringEncryptionFunctions(encryptString, decryptString) {\n    this._encryptString = encryptString;\n    this._decryptString = decryptString;\n  }\n\n  encryptPath(path, def) {\n    def = def || this._spec.rules;\n    path = path.slice();\n    for (var i = 0; i < path.length; i++) {\n      def = def[path[i]] || def.$;\n      if (!def) break;\n      if (def['.encrypt'] && def['.encrypt'].key) {\n        path[i] = this.encrypt(path[i], 'string', def['.encrypt'].key);\n      }\n    }\n    return path;\n  }\n\n  encryptRef(ref, path) {\n    var encryptedPath = this.encryptPath(path || this.refToPath(ref));\n    return encryptedPath.length ? ref.root.child(encryptedPath.join('/')) : ref.root;\n  }\n\n  decryptRef(ref) {\n    var path = this.refToPath(ref, true);\n    var changed = false;\n    for (var i = 0; i < path.length; i++) {\n      var decryptedPathSegment = this.decrypt(path[i]);\n      if (decryptedPathSegment !== path[i]) {\n        path[i] = decryptedPathSegment;\n        changed = true;\n      }\n    }\n    return changed ? ref.root.child(path.join('/')) : ref;\n  }\n\n  specForPath(path, def) {\n    def = def || this._spec.rules;\n    for (var i = 0; def && i < path.length; i++) {\n      def = def[path[i]] || def.$;\n    }\n    return def;\n  }\n\n  transformValue(path, value, transformType) {\n    if (transformType !== 'encrypt' && transformType !== 'decrypt') {\n      throw new Error(\n        `Transform type must be either \"encrypt\" or \"decrypt\", but got \"${transformType}\".`\n      );\n    }\n    const transform = transformType === 'encrypt' ? this.encrypt.bind(this) : this.decrypt.bind(this);\n    return this.transformTree(value, this.specForPath(path), transform);\n  }\n\n  transformTree(value, def, transform) {\n    if (!def) return value;\n    var type = this.getType(value);\n    var i;\n    if (/^(string|number|boolean)$/.test(type)) {\n      if (def['.encrypt'] && def['.encrypt'].value) {\n        value = transform(value, type, def['.encrypt'].value);\n      }\n    } else if (type === 'object' && value !== null) {\n      var transformedValue = {};\n      for (var key in value) {\n        if (!value.hasOwnProperty(key)) continue;\n        var subValue = value[key], subDef;\n        if (key.indexOf('/') >= 0) {  // for deep update keys\n          var keyParts = key.split('/');\n          subDef = def;\n          for (i = 0; i < keyParts.length; i++) {\n            if (transform === decrypt) {\n              keyParts[i] = this.decrypt(keyParts[i]);\n              subDef = subDef && (subDef[keyParts[i]] || subDef.$);\n            } else {\n              subDef = subDef && (subDef[keyParts[i]] || subDef.$);\n              if (subDef && subDef['.encrypt'] && subDef['.encrypt'].key) {\n                keyParts[i] = transform(keyParts[i], 'string', subDef['.encrypt'].key);\n              }\n            }\n          }\n          key = keyParts.join('/');\n        } else {\n          if (transform === this.decrypt) {\n            key = this.decrypt(key);\n            subDef = def[key] || def.$;\n          } else {\n            subDef = def[key] || def.$;\n            if (subDef && subDef['.encrypt'] && subDef['.encrypt'].key) {\n              key = transform(key, 'string', subDef['.encrypt'].key);\n            }\n          }\n        }\n        transformedValue[key] = this.transformTree(subValue, subDef, transform);\n      }\n      value = transformedValue;\n    } else if (type === 'array') {\n      if (!def.$) return value;\n      for (i = 0; i < value.length; i++) value[i] = this.transformTree(value[i], def.$, transform);\n    }\n    return value;\n  }\n\n  refToPath(ref, encrypted) {\n    var root = ref.root;\n    if (ref === root) return [];\n    var pathStr = decodeURIComponent(ref.toString().slice(root.toString().length));\n    if (!encrypted && pathStr && pathStr.charAt(0) !== '.' &&\n        /[\\x00-\\x1f\\x7f\\x91\\x92\\.#$\\[\\]]/.test(pathStr)) {\n      throw new Error('Path contains invalid characters: ' + pathStr);\n    }\n    return pathStr.split('/');\n  }\n\n  encrypt(value, type, pattern) {\n    var cacheKey;\n    if (this._encryptionCache) {\n      cacheKey = type.charAt(0) + pattern + '\\x91' + value;\n      if (this._encryptionCache.has(cacheKey)) return this._encryptionCache.get(cacheKey);\n    }\n    var result;\n    if (pattern === '#') {\n      result = this.encryptValue(value, type);\n    } else {\n      if (type !== 'string') {\n        throw new Error('Can\\'t encrypt a ' + type + ' using pattern [' + pattern + ']');\n      }\n      var match = value.match(this.compilePattern(pattern));\n      if (!match) {\n        throw new Error(\n          'Can\\'t encrypt as value doesn\\'t match pattern [' + pattern + ']: ' + value);\n      }\n      var i = 0;\n      result = pattern.replace(/[#\\.]/g, function(placeholder) {\n        var part = match[++i];\n        if (placeholder === '#') part = this.encryptValue(part, 'string');\n        return part;\n      });\n    }\n    if (this._encryptionCache) this._encryptionCache.set(cacheKey, result);\n    return result;\n  }\n\n  encryptValue(value, type) {\n    if (!/^(string|number|boolean)$/.test(type)) throw new Error('Can\\'t encrypt a ' + type);\n    switch (type) {\n      case 'number': value = '' + value; break;\n      case 'boolean': value = value ? 't' : 'f'; break;\n    }\n    return '\\x91' + type.charAt(0).toUpperCase() + this._encryptString(value) + '\\x92';\n  }\n\n  decrypt(value) {\n    if (this._decryptionCache && this._decryptionCache.has(value)) return this._decryptionCache.get(value);\n    if (!/\\x91/.test(value)) return value;\n    var result;\n    var match = value.match(/^\\x91(.)([^\\x92]*)\\x92$/);\n    if (match) {\n      var decryptedString = this._decryptString(match[2]);\n      switch (match[1]) {\n        case 'S':\n          result = decryptedString;\n          break;\n        case 'N':\n          result = Number(decryptedString);\n          // Check for NaN, since it's the only value where x !== x.\n          if (result !== result) throw new Error('Invalid encrypted number: ' + decryptedString);\n          break;\n        case 'B':\n          if (decryptedString === 't') result = true;\n          else if (decryptedString === 'f') result = false;\n          else throw new Error('Invalid encrypted boolean: ' + decryptedString);\n          break;\n        default:\n          throw new Error('Invalid encrypted value type code: ' + match[1]);\n      }\n    } else {\n      result = value.replace(/\\x91(.)([^\\x92]*)\\x92/g, function(match, typeCode, encryptedString) {\n        if (typeCode !== 'S') throw new Error('Invalid multi-segment encrypted value: ' + typeCode);\n        return this._decryptString(encryptedString);\n      });\n    }\n    if (this._decryptionCache) this._decryptionCache.set(value, result);\n    return result;\n  }\n\n  getType(value) {\n    if (Array.isArray(value)) return 'array';\n    var type = typeof value;\n    if (type === 'object') {\n      if (value instanceof String) type = 'string';\n      else if (value instanceof Number) type = 'number';\n      else if (value instanceof Boolean) type = 'boolean';\n    }\n    return type;\n  }\n\n  compilePattern(pattern) {\n    var regex = this._patternRegexes[pattern];\n    if (!regex) {\n      regex = this._patternRegexes[pattern] = new RegExp('^' + pattern\n        .replace(/\\./g, '#')\n        .replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')  // escape regex chars\n        .replace(/#/g, '(.*?)') + '$');\n    }\n    return regex;\n  }\n}\n","import FireCryptReference from './FireCryptReference';\n\nexport default class FireCryptSnapshot {\n  constructor(snap, crypto) {\n    this._ref = crypto.decryptRef(snap.ref);\n    this._path = crypto.refToPath(this._ref);\n    this._snap = snap;\n    this._crypto = crypto;\n\n  }\n\n  get key() {\n    return this._ref.key;\n  }\n\n  get ref() {\n    return new FireCryptReference(this._ref.ref, this._crypto);\n  }\n\n  val() {\n    return this._crypto.transformValue(this._path, this._snap.val(), 'decrypt');\n  }\n\n  child(childPath) {\n    return new FireCryptSnapshot(this._snap.child(childPath), this._crypto);\n  }\n\n  forEach(action) {\n    return this._snap.forEach((childSnap) => {\n      return action(new FireCryptSnapshot(childSnap), this._crypto);\n    });\n  }\n\n  exists() {\n    return this._snap.exists.apply(this._snap, arguments)\n  }\n\n  hasChild(childPath) {\n    childPath = this._crypto.encryptPath(childPath.split('/'), this._crypto.specForPath(this._path)).join('/');\n    return this._snap.hasChild(childPath);\n  }\n\n  hasChildren() {\n    return this._snap.hasChildren.apply(this._snap, arguments)\n  }\n\n  numChildren() {\n    return this._snap.numChildren.apply(this._snap, arguments)\n  }\n\n  toJSON() {\n    const json = this._snap.toJSON.apply(this._snap, arguments);\n    return this._crypto.transformValue(this._path, json, 'decrypt');\n  }\n}\n","import FireCryptSnapshot from './FireCryptSnapshot';\nimport FireCryptReference from './FireCryptReference';\n\nexport default class FireCryptQuery {\n  constructor(query, order, originalRef, crypto) {\n    this._query = query;\n    this._order = order || {};\n    this._originalRef = originalRef || query;\n    this._crypto = crypto;\n  }\n\n  _wrapQueryCallback(callback) {\n    if (!callback || callback.firecryptCallback) return;\n    const wrappedCallback = (snap, previousChildKey) => {\n      return callback.call(this, new FireCryptSnapshot(snap, this._crypto), previousChildKey, this._crypto);\n    };\n    wrappedCallback.firecryptCallback = wrappedCallback;\n    callback.firecryptCallback = wrappedCallback;\n  }\n\n  get ref() {\n    return new FireCryptReference(this._crypto.decryptRef(this._query.ref), this._crypto);\n  }\n\n  on(eventType, callback, cancelCallback, context) {\n    this._wrapQueryCallback(callback);\n    return this._originalRef.on.call(\n      this._query, eventType, callback.firecryptCallback, cancelCallback, context);\n  }\n\n  off(eventType, callback, context) {\n    if (callback && callback.firecryptCallback) callback = callback.firecryptCallback;\n    return this._originalRef.off.call(this._query, eventType, callback, context);\n  }\n\n  once(eventType, successCallback, failureCallback, context) {\n    this._wrapQueryCallback(successCallback);\n    return this._originalRef.once.call(\n      this._query, eventType, successCallback && successCallback.firecryptCallback, failureCallback,\n      context\n    ).then((snap) => {\n      return new FireCryptSnapshot(snap, this._crypto);\n    });\n  }\n  \n  orderByChild(key) {\n    return this._orderBy('orderByChild', 'child', key);\n  }\n\n  orderByKey() {\n    return this._orderBy('orderByKey', 'key');\n  }\n\n  orderByValue() {\n    return this._orderBy('orderByValue', 'value');\n  }\n\n  startAt(value, key) {\n    this._checkCanSort(key !== undefined);\n    return this._delegate('startAt', arguments);\n  }\n\n  endAt(value, key) {\n    this._checkCanSort(key !== undefined);\n    return this._delegate('endAt', arguments);\n  }\n\n  equalTo(value, key) {\n    if (this._order[this._order.by + 'Encrypted']) {\n      value = this._crypto.encrypt(value, this._crypto.getType(value), this._order[this._order.by + 'Encrypted']);\n    }\n    if (key !== undefined && this._order.keyEncrypted) {\n      key = this._crypto.encrypt(key, 'string', this._order.keyEncrypted);\n    }\n    return new FireCryptQuery(this._originalRef.equalTo.call(this._query, value, key), this._order, this._crypto);\n  }\n\n  limitToFirst() {\n    return this._delegate('limitToFirst', arguments);\n  }\n\n  limitToLast() {\n    return this._delegate('limitToLast', arguments);\n  }\n\n  limit() {\n    return this._delegate('limit', arguments);\n  }\n\n  _delegate(methodName, args) {\n    return new FireCryptQuery(this._originalRef[methodName].apply(this._query, args), this._order, this._crypto);\n  }\n\n  _checkCanSort(hasExtraKey) {\n    if (this._order.by === 'key' ?\n        this._order.keyEncrypted :\n        this._order.valueEncrypted || hasExtraKey && this._order.keyEncrypted) {\n      throw new Error('Encrypted items cannot be ordered');\n    }\n  }\n\n  _orderBy(methodName, by, childKey) {\n    const def = this._crypto.specForPath(this._crypto.refToPath(this.ref));\n    const order = {by: by}\n\n    let encryptedChildKey;\n    if (def) {\n      const childPath = childKey && childKey.split('/');\n      for (const subKey in def) {\n        if (!def.hasOwnProperty(subKey)) continue;\n        const subDef = def[subKey];\n        if (subDef['.encrypt']) {\n          if (subDef['.encrypt'].key) order.keyEncrypted = subDef['.encrypt'].key;\n          if (subDef['.encrypt'].value) order.valueEncrypted = subDef['.encrypt'].value;\n        }\n        if (childKey) {\n          const childDef = this._crypto.specForPath(childPath, subDef);\n          if (childDef && childDef['.encrypt'] && childDef['.encrypt'].value) {\n            order.childEncrypted = childDef['.encrypt'].value;\n          }\n          const encryptedChildKeyCandidate = this._crypto.encryptPath(childPath, subDef).join('/');\n          if (encryptedChildKey && encryptedChildKeyCandidate !== encryptedChildKey) {\n            throw new Error(\n              'Incompatible encryption specifications for orderByChild(\"' + childKey + '\")');\n          }\n          encryptedChildKey = encryptedChildKeyCandidate;\n        }\n      }\n    }\n    if (childKey) {\n      return new FireCryptQuery(\n        this._originalRef[methodName].call(this._query, encryptedChildKey || childKey), order, this._crypto);\n    } else {\n      return new FireCryptQuery(this._originalRef[methodName].call(this._query), order, this._crypto);\n    }\n  }\n}\n","export default class FireCryptOnDisconnect {\n  constructor(path, originalOnDisconnect, crypto) {\n    this._path = path;\n    this._crypto = crypto;\n    this._originalOnDisconnect = originalOnDisconnect;\n  }\n\n  _interceptOnDisconnectWrite(methodName, originalArguments, argIndex) {\n    const self = this;\n\n    this[methodName] = function() {\n      const args = Array.prototype.slice.call(originalArguments);\n      if (argIndex >= 0 && argIndex < args.length) {\n        args[argIndex] = self._crypto.transformValue(self._path, args[argIndex], 'encrypt');\n      }\n\n      return self._originalOnDisconnect[methodName].apply(self._originalOnDisconnect, args);\n    };\n  }\n\n  set() {\n    return this._interceptOnDisconnectWrite('set', arguments, 0);\n  }\n\n  update() {\n    return this._interceptOnDisconnectWrite('update', arguments, 0);\n  }\n\n  remove() {\n    return this._interceptOnDisconnectWrite('remove', arguments);\n  }\n\n  cancel() {\n    return this._interceptOnDisconnectWrite('cancel', arguments);\n  }\n}\n","import FireCryptQuery from './FireCryptQuery';\nimport FireCryptSnapshot from './FireCryptSnapshot';\nimport FireCryptOnDisconnect from './FireCryptOnDisconnect';\n\nlet childrenKeysFromLib;\ntry {\n  childrenKeysFromLib = require('firebase-childrenkeys');\n} catch (e) {\n  // Library is optional, so ignore any errors from failure to load it.\n}\n\nexport default class FireCryptReference {\n  constructor(ref, crypto) {\n    this._ref = ref;\n    this._crypto = crypto;\n  }\n\n  _interceptQuery(methodName, originalArguments) {\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n    const query = new FireCryptQuery(encryptedRef, {}, this._ref, this._crypto);\n    return query[methodName].apply(query, originalArguments);\n  }\n\n  _interceptWrite(methodName, originalArguments, argIndex) {\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n\n    const args = Array.prototype.slice.call(originalArguments);\n    if (argIndex >= 0 && argIndex < args.length) {\n      const path = this._crypto.refToPath(this._ref);\n      args[argIndex] = this._crypto.transformValue(path, args[argIndex], 'encrypt');\n    }\n\n    return this._ref[methodName].apply(encryptedRef, args);\n  }\n\n  /**\n   * Returns a placeholder value for auto-populating the current timestamp (time since the Unix\n   * epoch, in milliseconds) as determined by the Firebase servers.\n   * @return {Object} A timestamp placeholder value.\n   */\n  static get SERVER_TIMESTAMP() {\n    return {\n      '.sv': 'timestamp'\n    };\n  }\n\n  /**\n   * Returns the last part of this reference's path. The key of a root reference is `null`.\n   * @return {string|null} The last part this reference's path.\n   */\n  get key() {\n    return this._ref.key;\n  }\n\n  /**\n   * Returns just the path component of the reference's URL.\n   * @return {string} The path component of the Firebase URL wrapped by this reference.\n   */\n  get path() {\n    return decodeURIComponent(this._ref.toString()).slice(this._ref.root.toString().length - 1);\n  }\n\n  /**\n   * Returns a FireCryptReference at the same location as this query or reference.\n   * @return {FireCryptReference|null} A FireCryptReference at the same location as this query or\n   *     reference.\n   */\n  get ref() {\n    if (this._ref.isEqual(this._ref.ref)) {\n      return this;\n    } else {\n      return new FireCryptReference(this._ref.ref, this._crypto);\n    }\n  }\n\n  /**\n   * Returns a FireCryptReference reference to the root of the database.\n   * @return {FireCryptReference} The root reference of the database.\n   */\n  get root() {\n    if (this._ref.isEqual(this._ref.root)) {\n      return this;\n    } else {\n      return new FireCryptReference(this._ref.root, this._crypto);\n    }\n  }\n\n  /**\n   * Returns a FireCryptReference to the parent location of this reference. The parent of a root\n   * reference is `null`.\n   * @return {FireCryptReference|null} The parent location of this reference.\n   */\n  get parent() {\n    if (this._ref.parent === null) {\n      return null;\n    } else {\n      return new FireCryptReference(this._ref.parent, this._crypto);\n    }\n  }\n\n  /**\n   * Creates a new FireCryptReference object on a child of this one.\n   * @param  {string} path The path to the desired child, relative to this reference.\n   * @return {FireCryptReference} The child reference.\n   */\n  child(path) {\n    return new FireCryptReference(this._ref.child(path), this._crypto);\n  }\n\n  /**\n   * Returns a JSON-serializable representation of this object.\n   * @return {Object} A JSON-serializable representation of this object.\n   */\n  toJSON() {\n    return this._ref.toJSON();\n  }\n\n  /**\n   * Returns whether or not this FireCryptReference is equivalent to the provided FireCryptReference.\n   * @return {FireCryptReference} Another FireCryptReference instance against which to compare.\n   */\n  isEqual(otherRef) {\n    return this._ref.isEqual(otherRef._ref);\n  }\n\n  /**\n   * Stringifies the wrapped reference.\n   * @return {string} The Firebase URL wrapped by this FireCryptReference object.\n   */\n  toString() {\n    return decodeURIComponent(this._ref.toString());\n  }\n\n  push() {\n    const pushedRef = this.child(this._ref.push().key);\n    \n    let promise;\n    if (typeof arguments[0] === 'undefined') {\n      // A bare pushed ref should also be thennable.\n      promise = Promise.resolve();\n    } else {\n      promise = pushedRef.set.apply(pushedRef, arguments);\n    }\n\n    pushedRef.then = promise.then.bind(promise);\n    pushedRef.catch = promise.catch.bind(promise);\n    if (promise.finally) pushedRef.finally = promise.finally.bind(promise);\n\n    return pushedRef;\n  }\n\n  set() {\n    return this._interceptWrite('set', arguments, 0);\n  }\n\n  remove() {\n    return this._interceptWrite('remove', arguments);\n  }\n\n  update() {\n    return this._interceptWrite('update', arguments, 0);\n  }\n\n  childrenKeys() {\n    const originalMethod = this._ref.childrenKeys || childrenKeysFromLib;\n\n    if (typeof originalMethod !== 'function') {\n      throw new Error(\n        `childrenKeys() is not implemented. You must either provide a Firebase Database Reference\n        which implements childrenKeys() or npm install the firebase-children keys libary.`\n      );\n    }\n\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n    return originalMethod.apply(encryptedRef, [encryptedRef, ...arguments]).then((keys) => {\n      if (!keys.some((key) => /\\x91/.test(key))) {\n        return keys;\n      }\n      return keys.map(this._crypto.decrypt.bind(this._crypto));\n    });\n  }\n\n  onDisconnect() {\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n    return new FireCryptOnDisconnect(encryptedRef, this._ref.onDisconnect.call(encryptedRef), this._crypto);\n  }\n\n  on() {\n    return this._interceptQuery('on', arguments);\n  }\n\n  off() {\n    return this._interceptQuery('off', arguments);\n  }\n\n  once() {\n    return this._interceptQuery('once', arguments);\n  }\n\n  orderByChild() {\n    return this._interceptQuery('orderByChild', arguments);\n  }\n\n  orderByKey() {\n    return this._interceptQuery('orderByKey', arguments);\n  }\n\n  orderByValue() {\n    return this._interceptQuery('orderByValue', arguments);\n  }\n  \n  startAt() {\n    return this._interceptQuery('startAt', arguments);\n  }\n  \n  endAt() {\n    return this._interceptQuery('endAt', arguments);\n  }\n\n  equalTo() {\n    return this._interceptQuery('equalTo', arguments);\n  }\n\n  limitToFirst() {\n    return this._interceptQuery('limitToFirst', arguments);\n  }\n\n  limitToLast() {\n    return this._interceptQuery('limitToLast', arguments);\n  }\n\n  transaction() {\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n    const path = this._crypto.refToPath(this._ref);\n\n    const args = Array.prototype.slice.call(arguments);\n    const originalCompute = args[0];\n    args[0] = originalCompute && ((value) => {\n      value = this._crypto.transformValue(path, value, 'decrypt');\n      value = originalCompute(value);\n      value = this._crypto.transformValue(path, value, 'encrypt');\n      return value;\n    });\n    if (args.length > 1) {\n      const originalOnComplete = args[1];\n      args[1] = originalOnComplete && ((error, committed, snapshot) => {\n        return originalOnComplete(error, committed, snapshot && new FireCryptSnapshot(snapshot));\n      });\n    }\n    return this._ref.transaction.apply(encryptedRef, args).then((result) => {\n      result.snapshot = result.snapshot && new FireCryptSnapshot(result.snapshot, this._crypto);\n      return result;\n    });\n  };\n}\n","if (typeof require !== 'undefined') {\n  if (typeof LRUCache === 'undefined') global.LRUCache = require('lru-cache');\n  if (typeof CryptoJS === 'undefined') global.CryptoJS = require('crypto-js/core');\n  require('crypto-js/enc-base64');\n  require('cryptojs-extension/build_node/siv');\n}\n\nCryptoJS.enc.Base64UrlSafe = {\n  stringify: CryptoJS.enc.Base64.stringify,\n  parse: CryptoJS.enc.Base64.parse,\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n};\n\nimport Crypto from './crypto';\nimport FireCryptReference from './FireCryptReference';\n\nexport default class FireCrypt {\n  constructor(db) {\n    const dbIsNonNullObject = typeof db === 'object' && db !== null;\n    if (!dbIsNonNullObject || typeof db.app !== 'object' || typeof db.ref !== 'function') {\n      throw new Error(\n        `Expected first argument passed to FireCrypt constructor to be a Firebase Database instance, \n        but got \"${db}\".`\n      );\n    }\n\n    this._db = db;\n    this._crypto = undefined;\n  }\n\n  _ensureEncryptionConfigured() {\n    if (typeof this._crypto === 'undefined') {\n      throw new Error('Encryption for this FireCrypt reference has not been configured yet.');\n    }\n  }\n\n  _setupAesSiv(key, checkValue) {\n    const siv = CryptoJS.SIV.create(CryptoJS.enc.Base64.parse(key));\n    const encryptString = (str) => {\n      return CryptoJS.enc.Base64UrlSafe.stringify(siv.encrypt(str));\n    };\n    const decryptString = (str) => {\n      const result = siv.decrypt(CryptoJS.enc.Base64UrlSafe.parse(str));\n      if (result === false) {\n        const e = new Error('Wrong decryption key');\n        e.firecrypt = 'WRONG_KEY';\n        throw e;\n      }\n      return CryptoJS.enc.Utf8.stringify(result);\n    };\n  \n    this._crypto.setStringEncryptionFunctions(encryptString, decryptString);\n  \n    if (checkValue) decryptString(checkValue);\n    return encryptString(CryptoJS.enc.Base64UrlSafe.stringify(CryptoJS.lib.WordArray.random(10)));\n  }\n\n  get app() {\n    this._ensureEncryptionConfigured();\n    return this._db.app;\n  }\n\n  configureEncryption(options = {}, specification = {}) {\n    if (typeof options !== 'object' || options === null) {\n      throw new Error(\n        `Expected second argument passed to configureEncryption() to be an object, but got \"${options}\".`\n      );\n    } else if (typeof specification !== 'object' || specification === null) {\n      throw new Error(\n        `Expected third argument passed to configureEncryption() to be an object, but got \"${specification}\".`\n      );\n    }\n\n    options.cacheSize = options.cacheSize || 5 * 1000 * 1000;\n    options.encryptionCacheSize = options.encryptionCacheSize || options.cacheSize;\n    options.decryptionCacheSize = options.decryptionCacheSize || options.cacheSize;\n\n    this._crypto = new Crypto(options, specification);\n\n    let result;\n\n    switch (options.algorithm) {\n      case 'aes-siv':\n        if (!options.key) throw new Error('You must specify a key to use AES encryption.');\n        result = this._setupAesSiv(options.key, options.keyCheckValue);\n        break;\n      case 'passthrough':\n        this._crypto.setStringEncryptionFunctions((str) => str, (str) => str);\n        break;\n      case 'none':\n        break;\n      default:\n        throw new Error('Unknown encryption algorithm \"' + options.algorithm + '\".');\n    }\n\n    return result;\n  }\n\n  goOnline() {\n    this._ensureEncryptionConfigured();\n    return this._db.goOnline();\n  }\n\n  goOffline() {\n    this._ensureEncryptionConfigured();\n    return this._db.goOffline();\n  }\n\n  ref(path) {\n    this._ensureEncryptionConfigured();\n\n    if (typeof path !== 'undefined' && typeof path !== 'string') {\n      throw new Error(\n        `Expected first argument passed to ref() to be undefined or a string, but got \"${path}\".`\n      );\n    }\n\n    return new FireCryptReference(this._db.ref(path), this._crypto);\n  }\n\n  refFromURL(url) {\n    this._ensureEncryptionConfigured();\n\n    if (typeof url !== 'string' || url.match(/^https:\\/\\/.*/g) === null) {\n      throw new Error(\n        `Expected first argument passed to refFromURL() to be a string URL, but got \"${url}\".`\n      );\n    }\n\n    return new FireCryptReference(this._db.refFromURL(path), this._crypto);\n  }\n}\n"],"names":["Crypto","options","spec","_spec","this","_cleanSpecification","_encryptString","_throwNotSetUpError","_decryptString","_patternRegexes","LRUCache","_encryptionCache","encryptionCacheSize","_computeCacheItemSize","_decryptionCache","decryptionCacheSize","def","path","keys","Object","i","length","key","encryptKeys","j","encryptKey","Error","test","slice","charAt","$","e","firecrypt","value","encryptString","decryptString","rules","encrypt","ref","encryptedPath","encryptPath","refToPath","root","child","join","changed","decryptedPathSegment","decrypt","transformType","transform","bind","transformTree","specForPath","type","getType","transformedValue","hasOwnProperty","subDef","subValue","indexOf","keyParts","split","encrypted","pathStr","decodeURIComponent","toString","pattern","cacheKey","result","has","get","encryptValue","match","compilePattern","replace","placeholder","part","set","toUpperCase","decryptedString","Number","typeCode","encryptedString","Array","isArray","String","Boolean","regex","RegExp","FireCryptSnapshot","snap","crypto","_ref","decryptRef","_path","_snap","_crypto","FireCryptReference","transformValue","val","childPath","action","forEach","childSnap","exists","apply","arguments","hasChild","hasChildren","numChildren","json","toJSON","FireCryptQuery","query","order","originalRef","_query","_order","_originalRef","callback","firecryptCallback","wrappedCallback","previousChildKey","call","eventType","cancelCallback","context","_wrapQueryCallback","on","off","successCallback","failureCallback","once","then","_orderBy","_checkCanSort","undefined","_delegate","by","keyEncrypted","equalTo","methodName","args","hasExtraKey","valueEncrypted","childKey","encryptedChildKey","subKey","childDef","childEncrypted","encryptedChildKeyCandidate","FireCryptOnDisconnect","originalOnDisconnect","_originalOnDisconnect","originalArguments","argIndex","self","prototype","_interceptOnDisconnectWrite","childrenKeysFromLib","require","encryptedRef","encryptRef","isEqual","parent","otherRef","pushedRef","push","promise","Promise","resolve","catch","finally","_interceptWrite","originalMethod","childrenKeys","some","map","onDisconnect","_interceptQuery","originalCompute","originalOnComplete","error","committed","snapshot","transaction","global","CryptoJS","enc","Base64UrlSafe","Base64","stringify","parse","db","app","_db","checkValue","siv","SIV","create","str","Utf8","setStringEncryptionFunctions","lib","WordArray","random","_ensureEncryptionConfigured","specification","cacheSize","algorithm","_setupAesSiv","keyCheckValue","goOnline","goOffline","url","refFromURL"],"mappings":"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"}