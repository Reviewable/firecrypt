{"version":3,"file":"firecrypt.min.js","sources":["src/crypto.js","src/FireCryptSnapshot.js","src/FireCryptQuery.js","src/FireCryptOnDisconnect.js","src/FireCryptReference.js","src/firecrypt.js"],"sourcesContent":["export default class Crypto {\n  constructor(options, spec) {\n    this._spec = this._cleanSpecification(spec);\n    this._encryptString = this._throwNotSetUpError;\n    this._decryptString = this._throwNotSetUpError;\n\n    this._patternRegexes = {};\n\n    if (typeof LRUCache === 'function') {\n      this._encryptionCache = new LRUCache({\n        max: options.encryptionCacheSize,\n        length: this._computeCacheItemSize,\n      });\n      this._decryptionCache = new LRUCache({\n        max: options.decryptionCacheSize,\n        length: this._computeCacheItemSize,\n      });\n    }\n  }\n\n  _cleanSpecification(def, path) {\n    var keys = Object.keys(def);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      if (key === '.encrypt') {\n        var encryptKeys = Object.keys(def[key]);\n        for (var j = 0; j < encryptKeys.length; j++) {\n          var encryptKey = encryptKeys[j];\n          if (encryptKey !== 'key' && encryptKey !== 'value' && encryptKey !== 'few') {\n            throw new Error('Illegal .encrypt subkey: ' + encryptKeys[j]);\n          }\n        }\n      } else {\n        if (/[\\x00-\\x1f\\x7f\\x91\\x92\\.#\\[\\]/]/.test(key) || /[$]/.test(key.slice(1))) {\n          throw new Error('Illegal character in specification key: ' + key);\n        }\n        this._cleanSpecification(def[key], (path || '') + '/' + key);\n      }\n      switch (key.charAt(0)) {\n        case '$':\n          if (key === '$') break;\n          if (def.$) throw new Error('Multiple wildcard keys in specification at ' + path);\n          def.$ = def[key];\n          delete def[key];\n          break;\n        case '.':\n          if (key !== '.encrypt') throw new Error('Unknown directive at ' + path + ': ' + key);\n          break;\n      }\n    }\n    return def;\n  }\n\n  _throwNotSetUpError() {\n    var e = new Error('Encryption not set up');\n    e.firecrypt = 'NO_KEY';\n    throw e;\n  }\n\n  _computeCacheItemSize(value, key) {\n    return key.length + (typeof value === 'string' ? value.length : 4);\n  }\n\n  setStringEncryptionFunctions(encryptString, decryptString) {\n    this._encryptString = encryptString;\n    this._decryptString = decryptString;\n  }\n\n  encryptPath(path, def) {\n    def = def || this._spec.rules;\n    path = path.slice();\n    for (var i = 0; i < path.length; i++) {\n      def = def[path[i]] || def.$;\n      if (!def) break;\n      if (def['.encrypt'] && def['.encrypt'].key) {\n        path[i] = this.encrypt(path[i], 'string', def['.encrypt'].key);\n      }\n    }\n    return path;\n  }\n\n  encryptRef(ref, path) {\n    var encryptedPath = this.encryptPath(path || this.refToPath(ref));\n    return encryptedPath.length ? ref.root.child(encryptedPath.join('/')) : ref.root;\n  }\n\n  decryptRef(ref) {\n    var path = this.refToPath(ref, true);\n    var changed = false;\n    for (var i = 0; i < path.length; i++) {\n      var decryptedPathSegment = this.decrypt(path[i]);\n      if (decryptedPathSegment !== path[i]) {\n        path[i] = decryptedPathSegment;\n        changed = true;\n      }\n    }\n    return changed ? ref.root.child(path.join('/')) : ref;\n  }\n\n  specForPath(path, def) {\n    def = def || this._spec.rules;\n    for (var i = 0; def && i < path.length; i++) {\n      def = def[path[i]] || def.$;\n    }\n    return def;\n  }\n\n  transformValue(path, value, transform) {\n    return this.transformTree(value, this.specForPath(path), transform);\n  }\n\n  transformTree(value, def, transform) {\n    if (!def) return value;\n    var type = this.getType(value);\n    var i;\n    if (/^(string|number|boolean)$/.test(type)) {\n      if (def['.encrypt'] && def['.encrypt'].value) {\n        value = transform(value, type, def['.encrypt'].value);\n      }\n    } else if (type === 'object' && value !== null) {\n      var transformedValue = {};\n      for (var key in value) {\n        if (!value.hasOwnProperty(key)) continue;\n        var subValue = value[key], subDef;\n        if (key.indexOf('/') >= 0) {  // for deep update keys\n          var keyParts = key.split('/');\n          subDef = def;\n          for (i = 0; i < keyParts.length; i++) {\n            if (transform === decrypt) {\n              keyParts[i] = this.decrypt(keyParts[i]);\n              subDef = subDef && (subDef[keyParts[i]] || subDef.$);\n            } else {\n              subDef = subDef && (subDef[keyParts[i]] || subDef.$);\n              if (subDef && subDef['.encrypt'] && subDef['.encrypt'].key) {\n                keyParts[i] = transform(keyParts[i], 'string', subDef['.encrypt'].key);\n              }\n            }\n          }\n          key = keyParts.join('/');\n        } else {\n          if (transform === this.decrypt) {\n            key = this.decrypt(key);\n            subDef = def[key] || def.$;\n          } else {\n            subDef = def[key] || def.$;\n            if (subDef && subDef['.encrypt'] && subDef['.encrypt'].key) {\n              key = transform(key, 'string', subDef['.encrypt'].key);\n            }\n          }\n        }\n        transformedValue[key] = this.transformTree(subValue, subDef, transform);\n      }\n      value = transformedValue;\n    } else if (type === 'array') {\n      if (!def.$) return value;\n      for (i = 0; i < value.length; i++) value[i] = this.transformTree(value[i], def.$, transform);\n    }\n    return value;\n  }\n\n  refToPath(ref, encrypted) {\n    var root = ref.root;\n    if (ref === root) return [];\n    var pathStr = decodeURIComponent(ref.toString().slice(root.toString().length));\n    if (!encrypted && pathStr && pathStr.charAt(0) !== '.' &&\n        /[\\x00-\\x1f\\x7f\\x91\\x92\\.#$\\[\\]]/.test(pathStr)) {\n      throw new Error('Path contains invalid characters: ' + pathStr);\n    }\n    return pathStr.split('/');\n  }\n\n  encrypt(value, type, pattern) {\n    var cacheKey;\n    if (this._encryptionCache) {\n      cacheKey = type.charAt(0) + pattern + '\\x91' + value;\n      if (this._encryptionCache.has(cacheKey)) return this._encryptionCache.get(cacheKey);\n    }\n    var result;\n    if (pattern === '#') {\n      result = this.encryptValue(value, type);\n    } else {\n      if (type !== 'string') {\n        throw new Error('Can\\'t encrypt a ' + type + ' using pattern [' + pattern + ']');\n      }\n      var match = value.match(this.compilePattern(pattern));\n      if (!match) {\n        throw new Error(\n          'Can\\'t encrypt as value doesn\\'t match pattern [' + pattern + ']: ' + value);\n      }\n      var i = 0;\n      result = pattern.replace(/[#\\.]/g, function(placeholder) {\n        var part = match[++i];\n        if (placeholder === '#') part = this.encryptValue(part, 'string');\n        return part;\n      });\n    }\n    if (this._encryptionCache) this._encryptionCache.set(cacheKey, result);\n    return result;\n  }\n\n  encryptValue(value, type) {\n    if (!/^(string|number|boolean)$/.test(type)) throw new Error('Can\\'t encrypt a ' + type);\n    switch (type) {\n      case 'number': value = '' + value; break;\n      case 'boolean': value = value ? 't' : 'f'; break;\n    }\n    return '\\x91' + type.charAt(0).toUpperCase() + this._encryptString(value) + '\\x92';\n  }\n\n  decrypt(value) {\n    if (this._decryptionCache && this._decryptionCache.has(value)) return this._decryptionCache.get(value);\n    if (!/\\x91/.test(value)) return value;\n    var result;\n    var match = value.match(/^\\x91(.)([^\\x92]*)\\x92$/);\n    if (match) {\n      var decryptedString = this._decryptString(match[2]);\n      switch (match[1]) {\n        case 'S':\n          result = decryptedString;\n          break;\n        case 'N':\n          result = Number(decryptedString);\n          // Check for NaN, since it's the only value where x !== x.\n          if (result !== result) throw new Error('Invalid encrypted number: ' + decryptedString);\n          break;\n        case 'B':\n          if (decryptedString === 't') result = true;\n          else if (decryptedString === 'f') result = false;\n          else throw new Error('Invalid encrypted boolean: ' + decryptedString);\n          break;\n        default:\n          throw new Error('Invalid encrypted value type code: ' + match[1]);\n      }\n    } else {\n      result = value.replace(/\\x91(.)([^\\x92]*)\\x92/g, function(match, typeCode, encryptedString) {\n        if (typeCode !== 'S') throw new Error('Invalid multi-segment encrypted value: ' + typeCode);\n        return this._decryptString(encryptedString);\n      });\n    }\n    if (this._decryptionCache) this._decryptionCache.set(value, result);\n    return result;\n  }\n\n  getType(value) {\n    if (Array.isArray(value)) return 'array';\n    var type = typeof value;\n    if (type === 'object') {\n      if (value instanceof String) type = 'string';\n      else if (value instanceof Number) type = 'number';\n      else if (value instanceof Boolean) type = 'boolean';\n    }\n    return type;\n  }\n\n  compilePattern(pattern) {\n    var regex = this._patternRegexes[pattern];\n    if (!regex) {\n      regex = this._patternRegexes[pattern] = new RegExp('^' + pattern\n        .replace(/\\./g, '#')\n        .replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')  // escape regex chars\n        .replace(/#/g, '(.*?)') + '$');\n    }\n    return regex;\n  }\n}\n","import FireCryptReference from './FireCryptReference';\n\nexport default class FireCryptSnapshot {\n  constructor(snap, crypto) {\n    this._ref = crypto.decryptRef(snap.ref);\n    this._path = crypto.refToPath(this._ref);\n    this._snap = snap;\n    this._crypto = crypto;\n\n  }\n\n  get key() {\n    return this._ref.key;\n  }\n\n  get ref() {\n    return new FireCryptReference(this._ref.ref, this._crypto);\n  }\n\n  val() {\n    return this._crypto.transformValue(this._path, this._snap.val(), this._crypto.decrypt.bind(this._crypto));\n  }\n\n  child(childPath) {\n    return new FireCryptSnapshot(this._snap.child(childPath), this._crypto);\n  }\n\n  forEach(action) {\n    return this._snap.forEach((childSnap) => {\n      return action(new FireCryptSnapshot(childSnap), this._crypto);\n    });\n  }\n\n  exists() {\n    return this._snap.exists.apply(this._snap, arguments)\n  }\n\n  hasChild(childPath) {\n    childPath = this._crypto.encryptPath(childPath.split('/'), this._crypto.specForPath(this._path)).join('/');\n    return this._snap.hasChild(childPath);\n  }\n\n  hasChildren() {\n    return this._snap.hasChildren.apply(this._snap, arguments)\n  }\n\n  numChildren() {\n    return this._snap.numChildren.apply(this._snap, arguments)\n  }\n\n  toJSON() {\n    const json = this._snap.toJSON.apply(this._snap, arguments);\n    return this._crypto.transformValue(this._path, json, this._crypto.decrypt.bind(this._crypto));\n  }\n}\n","import FireCryptSnapshot from './FireCryptSnapshot';\nimport FireCryptReference from './FireCryptReference';\n\nexport default class FireCryptQuery {\n  constructor(query, order, originalRef, crypto) {\n    this._query = query;\n    this._order = order || {};\n    this._originalRef = originalRef || query;\n    this._crypto = crypto;\n  }\n\n  _wrapQueryCallback(callback) {\n    if (!callback || callback.firecryptCallback) return;\n    const wrappedCallback = (snap, previousChildKey) => {\n      return callback.call(this, new FireCryptSnapshot(snap, this._crypto), previousChildKey, this._crypto);\n    };\n    wrappedCallback.firecryptCallback = wrappedCallback;\n    callback.firecryptCallback = wrappedCallback;\n  }\n\n  get ref() {\n    return new FireCryptReference(this._crypto.decryptRef(this._query.ref), this._crypto);\n  }\n\n  on(eventType, callback, cancelCallback, context) {\n    this._wrapQueryCallback(callback);\n    return this._originalRef.on.call(\n      this._query, eventType, callback.firecryptCallback, cancelCallback, context);\n  }\n\n  off(eventType, callback, context) {\n    if (callback && callback.firecryptCallback) callback = callback.firecryptCallback;\n    return this._originalRef.off.call(this._query, eventType, callback, context);\n  }\n\n  once(eventType, successCallback, failureCallback, context) {\n    this._wrapQueryCallback(successCallback);\n    return this._originalRef.once.call(\n      this._query, eventType, successCallback && successCallback.firecryptCallback, failureCallback,\n      context\n    ).then((snap) => {\n      return new FireCryptSnapshot(snap, this._crypto);\n    });\n  }\n  \n  orderByChild(key) {\n    return this._orderBy('orderByChild', 'child', key);\n  }\n\n  orderByKey() {\n    return this._orderBy('orderByKey', 'key');\n  }\n\n  orderByValue() {\n    return this._orderBy('orderByValue', 'value');\n  }\n\n  startAt(value, key) {\n    this._checkCanSort(key !== undefined);\n    return this._delegate('startAt', arguments);\n  }\n\n  endAt(value, key) {\n    this._checkCanSort(key !== undefined);\n    return this._delegate('endAt', arguments);\n  }\n\n  equalTo(value, key) {\n    if (this._order[this._order.by + 'Encrypted']) {\n      value = this._crypto.encrypt(value, this._crypto.getType(value), this._order[this._order.by + 'Encrypted']);\n    }\n    if (key !== undefined && this._order.keyEncrypted) {\n      key = this._crypto.encrypt(key, 'string', this._order.keyEncrypted);\n    }\n    return new FireCryptQuery(this._originalRef.equalTo.call(this._query, value, key), this._order, this._crypto);\n  }\n\n  limitToFirst() {\n    return this._delegate('limitToFirst', arguments);\n  }\n\n  limitToLast() {\n    return this._delegate('limitToLast', arguments);\n  }\n\n  limit() {\n    return this._delegate('limit', arguments);\n  }\n\n  _delegate(methodName, args) {\n    return new FireCryptQuery(this._originalRef[methodName].apply(this._query, args), this._order, this._crypto);\n  }\n\n  _checkCanSort(hasExtraKey) {\n    if (this._order.by === 'key' ?\n        this._order.keyEncrypted :\n        this._order.valueEncrypted || hasExtraKey && this._order.keyEncrypted) {\n      throw new Error('Encrypted items cannot be ordered');\n    }\n  }\n\n  _orderBy(methodName, by, childKey) {\n    const def = this._crypto.specForPath(this._crypto.refToPath(this.ref));\n    const order = {by: by}\n\n    let encryptedChildKey;\n    if (def) {\n      const childPath = childKey && childKey.split('/');\n      for (const subKey in def) {\n        if (!def.hasOwnProperty(subKey)) continue;\n        const subDef = def[subKey];\n        if (subDef['.encrypt']) {\n          if (subDef['.encrypt'].key) order.keyEncrypted = subDef['.encrypt'].key;\n          if (subDef['.encrypt'].value) order.valueEncrypted = subDef['.encrypt'].value;\n        }\n        if (childKey) {\n          const childDef = this._crypto.specForPath(childPath, subDef);\n          if (childDef && childDef['.encrypt'] && childDef['.encrypt'].value) {\n            order.childEncrypted = childDef['.encrypt'].value;\n          }\n          const encryptedChildKeyCandidate = this._crypto.encryptPath(childPath, subDef).join('/');\n          if (encryptedChildKey && encryptedChildKeyCandidate !== encryptedChildKey) {\n            throw new Error(\n              'Incompatible encryption specifications for orderByChild(\"' + childKey + '\")');\n          }\n          encryptedChildKey = encryptedChildKeyCandidate;\n        }\n      }\n    }\n    if (childKey) {\n      return new FireCryptQuery(\n        this._originalRef[methodName].call(this._query, encryptedChildKey || childKey), order, this._crypto);\n    } else {\n      return new FireCryptQuery(this._originalRef[methodName].call(this._query), order, this._crypto);\n    }\n  }\n}\n","export default class FireCryptOnDisconnect {\n  constructor(path, originalOnDisconnect, crypto) {\n    this._path = path;\n    this._crypto = crypto;\n    this._originalOnDisconnect = originalOnDisconnect;\n  }\n\n  _interceptOnDisconnectWrite(methodName, originalArguments, argIndex) {\n    const self = this;\n\n    this[methodName] = function() {\n      const args = Array.prototype.slice.call(originalArguments);\n      if (argIndex >= 0 && argIndex < args.length) {\n        args[argIndex] = self._crypto.transformValue(self._path, args[argIndex], self._crypto.encrypt.bind(self._crypto));\n      }\n\n      return self._originalOnDisconnect[methodName].apply(self._originalOnDisconnect, args);\n    };\n  }\n\n  set() {\n    return this._interceptOnDisconnectWrite('set', arguments, 0);\n  }\n\n  update() {\n    return this._interceptOnDisconnectWrite('update', arguments, 0);\n  }\n\n  remove() {\n    return this._interceptOnDisconnectWrite('remove', arguments);\n  }\n\n  cancel() {\n    return this._interceptOnDisconnectWrite('cancel', arguments);\n  }\n}\n","import FireCryptQuery from './FireCryptQuery';\nimport FireCryptSnapshot from './FireCryptSnapshot';\nimport FireCryptOnDisconnect from './FireCryptOnDisconnect';\n\nexport default class FireCryptReference {\n  constructor(ref, crypto) {\n    this._ref = ref;\n    this._crypto = crypto;\n\n    [\n      'on', 'off', 'once', 'orderByChild', 'orderByKey', 'orderByValue', 'startAt', 'endAt',\n      'equalTo', 'limitToFirst', 'limitToLast'\n    ].forEach((methodName) => {this._interceptQuery(methodName);});\n  }\n\n  /**\n   * Returns a placeholder value for auto-populating the current timestamp (time since the Unix\n   * epoch, in milliseconds) as determined by the Firebase servers.\n   * @return {Object} A timestamp placeholder value.\n   */\n  static get SERVER_TIMESTAMP() {\n    return {\n      '.sv': 'timestamp'\n    };\n  }\n\n  /**\n   * Returns the last part of this reference's path. The key of a root reference is `null`.\n   * @return {string|null} The last part this reference's path.\n   */\n  get key() {\n    return this._ref.key;\n  }\n\n  /**\n   * Returns just the path component of the reference's URL.\n   * @return {string} The path component of the Firebase URL wrapped by this reference.\n   */\n  get path() {\n    return decodeURIComponent(this._ref.toString()).slice(this._ref.root.toString().length - 1);\n  }\n\n  /**\n   * Returns a FireCryptReference at the same location as this query or reference.\n   * @return {FireCryptReference|null} A FireCryptReference at the same location as this query or\n   *     reference.\n   */\n  get ref() {\n    if (this._ref.isEqual(this._ref.ref)) {\n      return this;\n    } else {\n      return new FireCryptReference(this._ref.ref, this._crypto);\n    }\n  }\n\n  /**\n   * Returns a FireCryptReference reference to the root of the database.\n   * @return {FireCryptReference} The root reference of the database.\n   */\n  get root() {\n    if (this._ref.isEqual(this._ref.root)) {\n      return this;\n    } else {\n      return new FireCryptReference(this._ref.root, this._crypto);\n    }\n  }\n\n  /**\n   * Returns a FireCryptReference to the parent location of this reference. The parent of a root\n   * reference is `null`.\n   * @return {FireCryptReference|null} The parent location of this reference.\n   */\n  get parent() {\n    if (this._ref.parent === null) {\n      return null;\n    } else {\n      return new FireCryptReference(this._ref.parent, this._crypto);\n    }\n  }\n\n  /**\n   * Creates a new FireCryptReference object on a child of this one.\n   * @param  {string} path The path to the desired child, relative to this reference.\n   * @return {FireCryptReference} The child reference.\n   */\n  child(path) {\n    return new FireCryptReference(this._ref.child(path), this._crypto);\n  }\n\n  /**\n   * Returns a JSON-serializable representation of this object.\n   * @return {Object} A JSON-serializable representation of this object.\n   */\n  toJSON() {\n    return this._ref.toJSON();\n  }\n\n  /**\n   * Returns whether or not this FireCryptReference is equivalent to the provided FireCryptReference.\n   * @return {FireCryptReference} Another FireCryptReference instance against which to compare.\n   */\n  isEqual(otherRef) {\n    return this._ref.isEqual(otherRef._ref);\n  }\n\n  /**\n   * Stringifies the wrapped reference.\n   * @return {string} The Firebase URL wrapped by this FireCryptReference object.\n   */\n  toString() {\n    return decodeURIComponent(this._ref.toString());\n  }\n\n  push() {\n    const pushedRef = this._ref.push();\n\n    const args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] !== 'undefined') {\n      const encryptedRef = this._crypto.encryptRef(pushedRef);\n      const path = this._crypto.refToPath(pushedRef);\n\n      args[0] = this._crypto.transformValue(path, args[0], this._crypto.encrypt.bind(this._crypto));\n\n      pushedRef.set.apply(encryptedRef, args);\n    }\n\n    const decryptedPushedRef = new FireCryptReference(this._crypto.decryptRef(pushedRef), this._crypto);\n    decryptedPushedRef.then = pushedRef.then;\n    decryptedPushedRef.catch = pushedRef.catch;\n    if (pushedRef.finally) decryptedPushedRef.finally = pushedRef.finally;\n\n    return decryptedPushedRef;\n  }\n\n  _interceptWrite(methodName, originalArguments, argIndex) {\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n\n    const args = Array.prototype.slice.call(originalArguments);\n    if (argIndex >= 0 && argIndex < args.length) {\n      const path = this._crypto.refToPath(this._ref);\n      args[argIndex] = this._crypto.transformValue(path, args[argIndex], this._crypto.encrypt.bind(this._crypto));\n    }\n\n    return this._ref[methodName].apply(encryptedRef, args);\n  }\n\n  set() {\n    return this._interceptWrite('set', arguments, 0);\n  }\n\n  remove() {\n    return this._interceptWrite('remove', arguments);\n  }\n\n  update() {\n    return this._interceptWrite('update', arguments, 0);\n  }\n\n  childrenKeys() {\n    if (!this._ref.childrenKeys) {\n      throw new Error('childrenKeys() is not implemented.');\n    }\n\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n    return this._ref.childrenKeys.apply(encryptedRef, arguments).then((keys) => {\n      if (!keys.some((key) => /\\x91/.test(key))) {\n        return keys;\n      }\n      return keys.map(this._crypto.decrypt.bind(this._crypto));\n    });\n  }\n\n  onDisconnect() {\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n    return new FireCryptOnDisconnect(encryptedRef, this._ref.onDisconnect.call(encryptedRef), this._crypto);\n  }\n\n  _interceptQuery(methodName) {\n    const self = this;\n    this[methodName] = function() {\n      const encryptedRef = self._crypto.encryptRef(self._ref);\n      const query = new FireCryptQuery(encryptedRef, {}, self._ref, self._crypto);\n      return query[methodName].apply(query, arguments);\n    }\n  }\n\n  transaction() {\n    const self = this;\n\n    const encryptedRef = this._crypto.encryptRef(this._ref);\n    const path = this._crypto.refToPath(this._ref);\n\n    const args = Array.prototype.slice.call(arguments);\n    const originalCompute = args[0];\n    args[0] = originalCompute && function(value) {\n      value = self._crypto.transformValue(path, value, self._crypto.decrypt.bind(self._crypto));\n      value = originalCompute(value);\n      value = self._crypto.transformValue(path, value, self._crypto.encrypt.bind(self._crypto));\n      return value;\n    };\n    if (args.length > 1) {\n      const originalOnComplete = args[1];\n      args[1] = originalOnComplete && function(error, committed, snapshot) {\n        return originalOnComplete(error, committed, snapshot && new FireCryptSnapshot(snapshot));\n      };\n    }\n    return this._ref.transaction.apply(encryptedRef, args).then((result) => {\n      result.snapshot = result.snapshot && new FireCryptSnapshot(result.snapshot, this._crypto);\n      return result;\n    });\n  };\n}\n","if (typeof require !== 'undefined') {\n  if (typeof LRUCache === 'undefined') global.LRUCache = require('lru-cache');\n  if (typeof CryptoJS === 'undefined') global.CryptoJS = require('crypto-js/core');\n  require('crypto-js/enc-base64');\n  require('cryptojs-extension/build_node/siv');\n}\n\nCryptoJS.enc.Base64UrlSafe = {\n  stringify: CryptoJS.enc.Base64.stringify,\n  parse: CryptoJS.enc.Base64.parse,\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n};\n\nimport Crypto from './crypto';\nimport FireCryptReference from './FireCryptReference';\n\nexport default class FireCrypt {\n  constructor(db) {\n    const dbIsNonNullObject = typeof db === 'object' && db !== null;\n    if (!dbIsNonNullObject || typeof db.app !== 'object' || typeof db.ref !== 'function') {\n      throw new Error(\n        `Expected first argument passed to FireCrypt constructor to be a Firebase Database instance, \n        but got \"${db}\".`\n      );\n    }\n\n    this._db = db;\n    this._crypto = undefined;\n  }\n\n  _ensureEncryptionConfigured() {\n    if (typeof this._crypto === 'undefined') {\n      throw new Error('Encryption for this FireCrypt reference has not been configured yet.');\n    }\n  }\n\n  _setupAesSiv(key, checkValue) {\n    const siv = CryptoJS.SIV.create(CryptoJS.enc.Base64.parse(key));\n    const encryptString = (str) => {\n      return CryptoJS.enc.Base64UrlSafe.stringify(siv.encrypt(str));\n    };\n    const decryptString = (str) => {\n      const result = siv.decrypt(CryptoJS.enc.Base64UrlSafe.parse(str));\n      if (result === false) {\n        const e = new Error('Wrong decryption key');\n        e.firecrypt = 'WRONG_KEY';\n        throw e;\n      }\n      return CryptoJS.enc.Utf8.stringify(result);\n    };\n  \n    this._crypto.setStringEncryptionFunctions(encryptString, decryptString);\n  \n    if (checkValue) decryptString(checkValue);\n    return encryptString(CryptoJS.enc.Base64UrlSafe.stringify(CryptoJS.lib.WordArray.random(10)));\n  }\n\n  get app() {\n    this._ensureEncryptionConfigured();\n    return this._db.app;\n  }\n\n  configureEncryption(options = {}, specification = {}) {\n    if (typeof options !== 'object' || options === null) {\n      throw new Error(\n        `Expected second argument passed to configureEncryption() to be an object, but got \"${options}\".`\n      );\n    } else if (typeof specification !== 'object' || specification === null) {\n      throw new Error(\n        `Expected third argument passed to configureEncryption() to be an object, but got \"${specification}\".`\n      );\n    }\n\n    options.cacheSize = options.cacheSize || 5 * 1000 * 1000;\n    options.encryptionCacheSize = options.encryptionCacheSize || options.cacheSize;\n    options.decryptionCacheSize = options.decryptionCacheSize || options.cacheSize;\n\n    this._crypto = new Crypto(options, specification);\n\n    let result;\n\n    switch (options.algorithm) {\n      case 'aes-siv':\n        if (!options.key) throw new Error('You must specify a key to use AES encryption.');\n        result = this._setupAesSiv(options.key, options.keyCheckValue);\n        break;\n      case 'passthrough':\n        this._crypto.setStringEncryptionFunctions((str) => str, (str) => str);\n        break;\n      case 'none':\n        break;\n      default:\n        throw new Error('Unknown encryption algorithm \"' + options.algorithm + '\".');\n    }\n\n    return result;\n  }\n\n  goOnline() {\n    this._ensureEncryptionConfigured();\n    return this._db.goOnline();\n  }\n\n  goOffline() {\n    this._ensureEncryptionConfigured();\n    return this._db.goOffline();\n  }\n\n  ref(path) {\n    this._ensureEncryptionConfigured();\n\n    if (typeof path !== 'undefined' && typeof path !== 'string') {\n      throw new Error(\n        `Expected first argument passed to ref() to be undefined or a string, but got \"${path}\".`\n      );\n    }\n\n    return new FireCryptReference(this._db.ref(path), this._crypto);\n  }\n\n  refFromURL(url) {\n    this._ensureEncryptionConfigured();\n\n    if (typeof url !== 'string' || url.match(/^https:\\/\\/.*/g) === null) {\n      throw new Error(\n        `Expected first argument passed to refFromURL() to be a string URL, but got \"${url}\".`\n      );\n    }\n\n    return new FireCryptReference(this._db.refFromURL(path), this._crypto);\n  }\n}\n"],"names":["Crypto","options","spec","_spec","this","_cleanSpecification","_encryptString","_throwNotSetUpError","_decryptString","_patternRegexes","LRUCache","_encryptionCache","encryptionCacheSize","_computeCacheItemSize","_decryptionCache","decryptionCacheSize","def","path","keys","Object","i","length","key","encryptKeys","j","encryptKey","Error","test","slice","charAt","$","e","firecrypt","value","encryptString","decryptString","rules","encrypt","ref","encryptedPath","encryptPath","refToPath","root","child","join","changed","decryptedPathSegment","decrypt","transform","transformTree","specForPath","type","getType","transformedValue","hasOwnProperty","subDef","subValue","indexOf","keyParts","split","encrypted","pathStr","decodeURIComponent","toString","pattern","cacheKey","result","has","get","encryptValue","match","compilePattern","replace","placeholder","part","set","toUpperCase","decryptedString","Number","typeCode","encryptedString","Array","isArray","String","Boolean","regex","RegExp","FireCryptSnapshot","snap","crypto","_ref","decryptRef","_path","_snap","_crypto","FireCryptReference","transformValue","val","bind","childPath","action","forEach","childSnap","exists","apply","arguments","hasChild","hasChildren","numChildren","json","toJSON","FireCryptQuery","query","order","originalRef","_query","_order","_originalRef","callback","firecryptCallback","wrappedCallback","previousChildKey","call","eventType","cancelCallback","context","_wrapQueryCallback","on","off","successCallback","failureCallback","once","then","_orderBy","_checkCanSort","undefined","_delegate","by","keyEncrypted","equalTo","methodName","args","hasExtraKey","valueEncrypted","childKey","encryptedChildKey","subKey","childDef","childEncrypted","encryptedChildKeyCandidate","FireCryptOnDisconnect","originalOnDisconnect","_originalOnDisconnect","originalArguments","argIndex","self","prototype","_interceptOnDisconnectWrite","_interceptQuery","isEqual","parent","otherRef","pushedRef","push","encryptedRef","encryptRef","decryptedPushedRef","catch","finally","_interceptWrite","childrenKeys","some","map","onDisconnect","originalCompute","originalOnComplete","error","committed","snapshot","transaction","require","global","CryptoJS","enc","Base64UrlSafe","Base64","stringify","parse","db","app","_db","checkValue","siv","SIV","create","str","Utf8","setStringEncryptionFunctions","lib","WordArray","random","_ensureEncryptionConfigured","specification","cacheSize","algorithm","_setupAesSiv","keyCheckValue","goOnline","goOffline","url","refFromURL"],"mappings":"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"}