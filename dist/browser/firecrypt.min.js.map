{"version":3,"file":"firecrypt.min.js","sources":["src/crypto.js","src/FireCryptSnapshot.js","src/FireCryptQuery.js","src/FireCryptOnDisconnect.js","src/FireCryptReference.js","src/firecrypt.js"],"sourcesContent":["let _spec;\nlet _encryptString;\nlet _decryptString;\nlet _encryptionCache;\nlet _decryptionCache;\n\nexport function setSpec(spec) {\n  _spec = cleanSpecification(spec);\n}\n\nexport function setStringEncryptionFunctions(encryptString, decryptString) {\n  _encryptString = encryptString;\n  _decryptString = decryptString;\n}\n\nexport function setEncryptionCache(cache) {\n  _encryptionCache = cache;\n}\n\nexport function setDecryptionCache(cache) {\n  _decryptionCache = cache;\n}\n\nexport function cleanSpecification(def, path) {\n  var keys = Object.keys(def);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key === '.encrypt') {\n      var encryptKeys = Object.keys(def[key]);\n      for (var j = 0; j < encryptKeys.length; j++) {\n        var encryptKey = encryptKeys[j];\n        if (encryptKey !== 'key' && encryptKey !== 'value' && encryptKey !== 'few') {\n          throw new Error('Illegal .encrypt subkey: ' + encryptKeys[j]);\n        }\n      }\n    } else {\n      if (/[\\x00-\\x1f\\x7f\\x91\\x92\\.#\\[\\]/]/.test(key) || /[$]/.test(key.slice(1))) {\n        throw new Error('Illegal character in specification key: ' + key);\n      }\n      cleanSpecification(def[key], (path || '') + '/' + key);\n    }\n    switch (key.charAt(0)) {\n      case '$':\n        if (key === '$') break;\n        if (def.$) throw new Error('Multiple wildcard keys in specification at ' + path);\n        def.$ = def[key];\n        delete def[key];\n        break;\n      case '.':\n        if (key !== '.encrypt') throw new Error('Unknown directive at ' + path + ': ' + key);\n        break;\n    }\n  }\n  return def;\n}\n\nexport function throwNotSetUpError() {\n  var e = new Error('Encryption not set up');\n  e.firecrypt = 'NO_KEY';\n  throw e;\n}\n\nexport function computeCacheItemSize(value, key) {\n  return key.length + (typeof value === 'string' ? value.length : 4);\n}\n\nexport function encryptPath(path, def) {\n  def = def || _spec.rules;\n  path = path.slice();\n  for (var i = 0; i < path.length; i++) {\n    def = def[path[i]] || def.$;\n    if (!def) break;\n    if (def['.encrypt'] && def['.encrypt'].key) {\n      path[i] = encrypt(path[i], 'string', def['.encrypt'].key);\n    }\n  }\n  return path;\n}\n\nexport function encryptRef(ref, path) {\n  var encryptedPath = encryptPath(path || refToPath(ref));\n  return encryptedPath.length ? ref.root.child(encryptedPath.join('/')) : ref.root;\n}\n\nexport function decryptRef(ref) {\n  var path = refToPath(ref, true);\n  var changed = false;\n  for (var i = 0; i < path.length; i++) {\n    var decryptedPathSegment = decrypt(path[i]);\n    if (decryptedPathSegment !== path[i]) {\n      path[i] = decryptedPathSegment;\n      changed = true;\n    }\n  }\n  return changed ? ref.root.child(path.join('/')) : ref;\n}\n\nexport function specForPath(path, def) {\n  def = def || _spec.rules;\n  for (var i = 0; def && i < path.length; i++) {\n    def = def[path[i]] || def.$;\n  }\n  return def;\n}\n\nexport function transformValue(path, value, transform) {\n  return transformTree(value, specForPath(path), transform);\n}\n\nexport function transformTree(value, def, transform) {\n  if (!def) return value;\n  var type = getType(value);\n  var i;\n  if (/^(string|number|boolean)$/.test(type)) {\n    if (def['.encrypt'] && def['.encrypt'].value) {\n      value = transform(value, type, def['.encrypt'].value);\n    }\n  } else if (type === 'object' && value !== null) {\n    var transformedValue = {};\n    for (var key in value) {\n      if (!value.hasOwnProperty(key)) continue;\n      var subValue = value[key], subDef;\n      if (key.indexOf('/') >= 0) {  // for deep update keys\n        var keyParts = key.split('/');\n        subDef = def;\n        for (i = 0; i < keyParts.length; i++) {\n          if (transform === decrypt) {\n            keyParts[i] = decrypt(keyParts[i]);\n            subDef = subDef && (subDef[keyParts[i]] || subDef.$);\n          } else {\n            subDef = subDef && (subDef[keyParts[i]] || subDef.$);\n            if (subDef && subDef['.encrypt'] && subDef['.encrypt'].key) {\n              keyParts[i] = transform(keyParts[i], 'string', subDef['.encrypt'].key);\n            }\n          }\n        }\n        key = keyParts.join('/');\n      } else {\n        if (transform === decrypt) {\n          key = decrypt(key);\n          subDef = def[key] || def.$;\n        } else {\n          subDef = def[key] || def.$;\n          if (subDef && subDef['.encrypt'] && subDef['.encrypt'].key) {\n            key = transform(key, 'string', subDef['.encrypt'].key);\n          }\n        }\n      }\n      transformedValue[key] = transformTree(subValue, subDef, transform);\n    }\n    value = transformedValue;\n  } else if (type === 'array') {\n    if (!def.$) return value;\n    for (i = 0; i < value.length; i++) value[i] = transformTree(value[i], def.$, transform);\n  }\n  return value;\n}\n\nexport function refToPath(ref, encrypted) {\n  var root = ref.root;\n  if (ref === root) return [];\n  var pathStr = decodeURIComponent(ref.toString().slice(root.toString().length));\n  if (!encrypted && pathStr && pathStr.charAt(0) !== '.' &&\n      /[\\x00-\\x1f\\x7f\\x91\\x92\\.#$\\[\\]]/.test(pathStr)) {\n    throw new Error('Path contains invalid characters: ' + pathStr);\n  }\n  return pathStr.split('/');\n}\n\nexport function encrypt(value, type, pattern) {\n  var cacheKey;\n  if (_encryptionCache) {\n    cacheKey = type.charAt(0) + pattern + '\\x91' + value;\n    if (_encryptionCache.has(cacheKey)) return _encryptionCache.get(cacheKey);\n  }\n  var result;\n  if (pattern === '#') {\n    result = encryptValue(value, type);\n  } else {\n    if (type !== 'string') {\n      throw new Error('Can\\'t encrypt a ' + type + ' using pattern [' + pattern + ']');\n    }\n    var match = value.match(compilePattern(pattern));\n    if (!match) {\n      throw new Error(\n        'Can\\'t encrypt as value doesn\\'t match pattern [' + pattern + ']: ' + value);\n    }\n    var i = 0;\n    result = pattern.replace(/[#\\.]/g, function(placeholder) {\n      var part = match[++i];\n      if (placeholder === '#') part = encryptValue(part, 'string');\n      return part;\n    });\n  }\n  if (_encryptionCache) _encryptionCache.set(cacheKey, result);\n  return result;\n}\n\nexport function encryptValue(value, type) {\n  if (!/^(string|number|boolean)$/.test(type)) throw new Error('Can\\'t encrypt a ' + type);\n  switch (type) {\n    case 'number': value = '' + value; break;\n    case 'boolean': value = value ? 't' : 'f'; break;\n  }\n  return '\\x91' + type.charAt(0).toUpperCase() + _encryptString(value) + '\\x92';\n}\n\nexport function decrypt(value) {\n  if (_decryptionCache && _decryptionCache.has(value)) return _decryptionCache.get(value);\n  if (!/\\x91/.test(value)) return value;\n  var result;\n  var match = value.match(/^\\x91(.)([^\\x92]*)\\x92$/);\n  if (match) {\n    var decryptedString = _decryptString(match[2]);\n    switch (match[1]) {\n      case 'S':\n        result = decryptedString;\n        break;\n      case 'N':\n        result = Number(decryptedString);\n        // Check for NaN, since it's the only value where x !== x.\n        if (result !== result) throw new Error('Invalid encrypted number: ' + decryptedString);\n        break;\n      case 'B':\n        if (decryptedString === 't') result = true;\n        else if (decryptedString === 'f') result = false;\n        else throw new Error('Invalid encrypted boolean: ' + decryptedString);\n        break;\n      default:\n        throw new Error('Invalid encrypted value type code: ' + match[1]);\n    }\n  } else {\n    result = value.replace(/\\x91(.)([^\\x92]*)\\x92/g, function(match, typeCode, encryptedString) {\n      if (typeCode !== 'S') throw new Error('Invalid multi-segment encrypted value: ' + typeCode);\n      return _decryptString(encryptedString);\n    });\n  }\n  if (_decryptionCache) _decryptionCache.set(value, result);\n  return result;\n}\n\nexport function getType(value) {\n  if (Array.isArray(value)) return 'array';\n  var type = typeof value;\n  if (type === 'object') {\n    if (value instanceof String) type = 'string';\n    else if (value instanceof Number) type = 'number';\n    else if (value instanceof Boolean) type = 'boolean';\n  }\n  return type;\n}\n\nvar patternRegexes = {};\nexport function compilePattern(pattern) {\n  var regex = patternRegexes[pattern];\n  if (!regex) {\n    regex = patternRegexes[pattern] = new RegExp('^' + pattern\n      .replace(/\\./g, '#')\n      .replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')  // escape regex chars\n      .replace(/#/g, '(.*?)') + '$');\n  }\n  return regex;\n}\n","import * as crypto from './crypto';\nimport FireCryptReference from './FireCryptReference';\n\nexport default class FireCryptSnapshot {\n  constructor(snap) {\n    this._ref = crypto.decryptRef(snap.ref);\n    this._path = crypto.refToPath(this._ref);\n    this._snap = snap;\n\n    this._delegateSnapshot('exists');\n    this._delegateSnapshot('toJSON');\n    this._delegateSnapshot('hasChildren');\n    this._delegateSnapshot('numChildren');\n  }\n\n  _delegateSnapshot(methodName) {\n    this[methodName] = function() {\n      return this._snap[methodName].apply(this._snap, arguments);\n    };\n  }\n\n  get key() {\n    return this._ref.key;\n  }\n\n  get ref() {\n    return new FireCryptReference(this._ref.ref);\n  }\n\n  val() {\n    return crypto.transformValue(this._path, this._snap.val(), crypto.decrypt);\n  }\n\n  child(childPath) {\n    return new FireCryptSnapshot(this._snap.child(childPath));\n  }\n\n  forEach(action) {\n    return this._snap.forEach(function(childSnap) {\n      return action(new FireCryptSnapshot(childSnap));\n    });\n  }\n\n  hasChild(childPath) {\n    childPath = crypto.encryptPath(childPath.split('/'), crypto.specForPath(this._path)).join('/');\n    return this._snap.hasChild(childPath);\n  }\n\n  exportVal() {\n    return crypto.transformValue(this._path, this._snap.exportVal(), crypto.decrypt);\n  }\n}\n","import * as crypto from './crypto';\nimport FireCryptSnapshot from './FireCryptSnapshot';\nimport FireCryptReference from './FireCryptReference';\n\nexport default class FireCryptQuery {\n  constructor(query, order, originalRef) {\n    this._query = query;\n    this._order = order || {};\n    this._originalRef = originalRef || query;\n  }\n\n  get ref() {\n    return new FireCryptReference(crypto.decryptRef(this._query.ref));\n  }\n\n  on(eventType, callback, cancelCallback, context) {\n    wrapQueryCallback(callback);\n    return this._originalRef.on.call(\n      this._query, eventType, callback.firecryptCallback, cancelCallback, context);\n  }\n\n  off(eventType, callback, context) {\n    if (callback && callback.firecryptCallback) callback = callback.firecryptCallback;\n    return this._originalRef.off.call(this._query, eventType, callback, context);\n  }\n\n  once(eventType, successCallback, failureCallback, context) {\n    wrapQueryCallback(successCallback);\n    return this._originalRef.once.call(\n      this._query, eventType, successCallback && successCallback.firecryptCallback, failureCallback,\n      context\n    ).then((snap) => {\n      return new FireCryptSnapshot(snap);\n    });\n  }\n  \n  orderByChild(key) {\n    return this._orderBy('orderByChild', 'child', key);\n  }\n\n  orderByKey() {\n    return this._orderBy('orderByKey', 'key');\n  }\n\n  orderByValue() {\n    return this._orderBy('orderByValue', 'value');\n  }\n\n  startAt(value, key) {\n    this._checkCanSort(key !== undefined);\n    return this._delegate('startAt', arguments);\n  }\n\n  endAt(value, key) {\n    this._checkCanSort(key !== undefined);\n    return this._delegate('endAt', arguments);\n  }\n\n  equalTo(value, key) {\n    if (this._order[this._order.by + 'Encrypted']) {\n      value = crypto.encrypt(value, crypto.getType(value), this._order[this._order.by + 'Encrypted']);\n    }\n    if (key !== undefined && this._order.keyEncrypted) {\n      key = crypto.encrypt(key, 'string', this._order.keyEncrypted);\n    }\n    return new FireCryptQuery(this._originalRef.equalTo.call(this._query, value, key), this._order);\n  }\n\n  limitToFirst() {\n    return this._delegate('limitToFirst', arguments);\n  }\n\n  limitToLast() {\n    return this._delegate('limitToLast', arguments);\n  }\n\n  limit() {\n    return this._delegate('limit', arguments);\n  }\n\n  _delegate(methodName, args) {\n    return new FireCryptQuery(this._originalRef[methodName].apply(this._query, args), this._order);\n  }\n\n  _checkCanSort(hasExtraKey) {\n    if (this._order.by === 'key' ?\n        this._order.keyEncrypted :\n        this._order.valueEncrypted || hasExtraKey && this._order.keyEncrypted) {\n      throw new Error('Encrypted items cannot be ordered');\n    }\n  }\n\n  _orderBy(methodName, by, childKey) {\n    const def = crypto.specForPath(crypto.refToPath(this.ref));\n    const order = {by: by}\n\n    let encryptedChildKey;\n    if (def) {\n      const childPath = childKey && childKey.split('/');\n      for (const subKey in def) {\n        if (!def.hasOwnProperty(subKey)) continue;\n        const subDef = def[subKey];\n        if (subDef['.encrypt']) {\n          if (subDef['.encrypt'].key) order.keyEncrypted = subDef['.encrypt'].key;\n          if (subDef['.encrypt'].value) order.valueEncrypted = subDef['.encrypt'].value;\n        }\n        if (childKey) {\n          const childDef = crypto.specForPath(childPath, subDef);\n          if (childDef && childDef['.encrypt'] && childDef['.encrypt'].value) {\n            order.childEncrypted = childDef['.encrypt'].value;\n          }\n          const encryptedChildKeyCandidate = crypto.encryptPath(childPath, subDef).join('/');\n          if (encryptedChildKey && encryptedChildKeyCandidate !== encryptedChildKey) {\n            throw new Error(\n              'Incompatible encryption specifications for orderByChild(\"' + childKey + '\")');\n          }\n          encryptedChildKey = encryptedChildKeyCandidate;\n        }\n      }\n    }\n    if (childKey) {\n      return new FireCryptQuery(\n        this._originalRef[methodName].call(this._query, encryptedChildKey || childKey), order);\n    } else {\n      return new FireCryptQuery(this._originalRef[methodName].call(this._query), order);\n    }\n  }\n}\n\nfunction wrapQueryCallback(callback) {\n  if (!callback || callback.firecryptCallback) return;\n  const wrappedCallback = function(snap, previousChildKey) {\n    return callback.call(this, new FireCryptSnapshot(snap), previousChildKey);\n  };\n  wrappedCallback.firecryptCallback = wrappedCallback;\n  callback.firecryptCallback = wrappedCallback;\n}\n","import * as crypto from './crypto';\n\nexport default class FireCryptOnDisconnect {\n  constructor(path, originalOnDisconnect) {\n    this._path = path;\n    this._originalOnDisconnect = originalOnDisconnect;\n\n    this._interceptOnDisconnectWrite('set', 0);\n    this._interceptOnDisconnectWrite('update', 0);\n    this._interceptOnDisconnectWrite('remove');\n    this._interceptOnDisconnectWrite('cancel');\n  }\n\n  _interceptOnDisconnectWrite(methodName, argIndex) {\n    this[methodName] = function() {\n      const args = Array.prototype.slice.call(arguments);\n      if (argIndex >= 0 && argIndex < args.length) {\n        args[argIndex] = crypto.transformValue(this._path, args[argIndex], crypto.encrypt);\n      }\n\n      return this._originalOnDisconnect[methodName].apply(this._originalOnDisconnect, args);\n    };\n  }\n}\n","import * as crypto from './crypto';\nimport FireCryptQuery from './FireCryptQuery';\nimport FireCryptSnapshot from './FireCryptSnapshot';\nimport FireCryptOnDisconnect from './FireCryptOnDisconnect';\n\nexport default class FireCryptReference {\n  constructor(ref) {\n    this._ref = ref;\n\n    this._interceptPush();\n    this._interceptTransaction();\n    this._interceptOnDisconnect();\n\n    [\n      'on', 'off', 'once', 'orderByChild', 'orderByKey', 'orderByValue', 'startAt', 'endAt',\n      'equalTo', 'limitToFirst', 'limitToLast'\n    ].forEach((methodName) => {this._interceptQuery(methodName);});\n\n    this._interceptWrite('set', 0);\n    this._interceptWrite('remove');\n    this._interceptWrite('update', 0);\n\n    if (ref.childrenKeys) {\n      this._interceptChildrenKeys(ref);\n    }\n  }\n\n  /**\n   * Returns a placeholder value for auto-populating the current timestamp (time since the Unix\n   * epoch, in milliseconds) as determined by the Firebase servers.\n   * @return {Object} A timestamp placeholder value.\n   */\n  static get SERVER_TIMESTAMP() {\n    return {\n      '.sv': 'timestamp'\n    };\n  }\n\n  /**\n   * Returns the last part of this reference's path. The key of a root reference is `null`.\n   * @return {string|null} The last part this reference's path.\n   */\n  get key() {\n    return this._ref.key;\n  }\n\n  /**\n   * Returns just the path component of the reference's URL.\n   * @return {string} The path component of the Firebase URL wrapped by this reference.\n   */\n  get path() {\n    return decodeURIComponent(this._ref.toString()).slice(this._ref.root.toString().length - 1);\n  }\n\n  /**\n   * Returns a FireCryptReference at the same location as this query or reference.\n   * @return {FireCryptReference|null} A FireCryptReference at the same location as this query or\n   *     reference.\n   */\n  get ref() {\n    if (this._ref.isEqual(this._ref.ref)) {\n      return this;\n    } else {\n      return new FireCryptReference(this._ref.ref);\n    }\n  }\n\n  /**\n   * Returns a FireCryptReference reference to the root of the database.\n   * @return {FireCryptReference} The root reference of the database.\n   */\n  get root() {\n    if (this._ref.isEqual(this._ref.root)) {\n      return this;\n    } else {\n      return new FireCryptReference(this._ref.root);\n    }\n  }\n\n  /**\n   * Returns a FireCryptReference to the parent location of this reference. The parent of a root\n   * reference is `null`.\n   * @return {FireCryptReference|null} The parent location of this reference.\n   */\n  get parent() {\n    if (this._ref.parent === null) {\n      return null;\n    } else {\n      return new FireCryptReference(this._ref.parent);\n    }\n  }\n\n  /**\n   * Creates a new FireCryptReference object on a child of this one.\n   * @param  {string} path The path to the desired child, relative to this reference.\n   * @return {FireCryptReference} The child reference.\n   */\n  child(path) {\n    return new FireCryptReference(this._ref.child(path));\n  }\n\n  /**\n   * Returns a JSON-serializable representation of this object.\n   * @return {Object} A JSON-serializable representation of this object.\n   */\n  toJSON() {\n    return this._ref.toJSON();\n  }\n\n  /**\n   * Returns whether or not this FireCryptReference is equivalent to the provided FireCryptReference.\n   * @return {FireCryptReference} Another FireCryptReference instance against which to compare.\n   */\n  isEqual(otherRef) {\n    return this._ref.isEqual(otherRef._ref);\n  }\n\n  /**\n   * Stringifies the wrapped reference.\n   * @return {string} The Firebase URL wrapped by this FireCryptReference object.\n   */\n  toString() {\n    return decodeURIComponent(this._ref.toString());\n  }\n\n  _interceptPush() {\n    this.push = function() {\n      const pushedRef = this._ref.push();\n\n      const args = Array.prototype.slice.call(arguments);\n      if (typeof args[0] !== 'undefined') {\n        const encryptedRef = crypto.encryptRef(pushedRef);\n        const path = crypto.refToPath(pushedRef);\n\n        args[0] = crypto.transformValue(path, args[0], crypto.encrypt);\n\n        pushedRef.set.apply(encryptedRef, args);\n      }\n\n      const decryptedPushedRef = new FireCryptReference(crypto.decryptRef(pushedRef));\n      decryptedPushedRef.then = pushedRef.then;\n      decryptedPushedRef.catch = pushedRef.catch;\n      if (pushedRef.finally) decryptedPushedRef.finally = pushedRef.finally;\n\n      return decryptedPushedRef;\n    };\n  }\n\n  _interceptWrite(methodName, argIndex) {\n    this[methodName] = function() {\n      const encryptedRef = crypto.encryptRef(this._ref);\n      const path = crypto.refToPath(this._ref);\n  \n      const args = Array.prototype.slice.call(arguments);\n      if (argIndex >= 0 && argIndex < args.length) {\n        args[argIndex] = crypto.transformValue(path, args[argIndex], crypto.encrypt);\n      }\n  \n      return this._ref[methodName].apply(encryptedRef, args);\n    };\n  }\n\n  _interceptChildrenKeys() {\n    this.childrenKeys = function() {\n      const encryptedRef = crypto.encryptRef(this._ref);\n      return this._ref.childrenKeys.apply(encryptedRef, arguments).then((keys) => {\n        if (!keys.some((key) => /\\x91/.test(key))) {\n          return keys;\n        }\n        return keys.map(crypto.decrypt);\n      });\n    };\n  }\n\n  _interceptOnDisconnect() {\n    this.onDisconnect = function() {\n      const encryptedRef = crypto.encryptRef(this._ref);\n      return new FireCryptOnDisconnect(encryptedRef, this._ref.onDisconnect.call(encryptedRef));\n    };\n  }\n\n  _interceptQuery(methodName) {\n    this[methodName] = function() {\n      const encryptedRef = crypto.encryptRef(this._ref);\n      const query = new FireCryptQuery(encryptedRef, {}, this._ref);\n      return query[methodName].apply(query, arguments);\n    }\n  }\n\n  _interceptTransaction() {\n    this.transaction = function() {\n      const encryptedRef = crypto.encryptRef(this._ref);\n      const path = crypto.refToPath(this._ref);\n\n      const args = Array.prototype.slice.call(arguments);\n      const originalCompute = args[0];\n      args[0] = originalCompute && function(value) {\n        value = crypto.transformValue(path, value, crypto.decrypt);\n        value = originalCompute(value);\n        value = crypto.transformValue(path, value, crypto.encrypt);\n        return value;\n      };\n      if (args.length > 1) {\n        const originalOnComplete = args[1];\n        args[1] = originalOnComplete && function(error, committed, snapshot) {\n          return originalOnComplete(error, committed, snapshot && new FireCryptSnapshot(snapshot));\n        };\n      }\n      return this._ref.transaction.apply(encryptedRef, args).then(function(result) {\n        result.snapshot = result.snapshot && new FireCryptSnapshot(result.snapshot);\n        return result;\n      });\n    };\n  }\n}\n","if (typeof require !== 'undefined') {\n  if (typeof LRUCache === 'undefined') global.LRUCache = require('lru-cache');\n  if (typeof CryptoJS === 'undefined') global.CryptoJS = require('crypto-js/core');\n  require('crypto-js/enc-base64');\n  require('cryptojs-extension/build_node/siv');\n}\n\nCryptoJS.enc.Base64UrlSafe = {\n  stringify: CryptoJS.enc.Base64.stringify,\n  parse: CryptoJS.enc.Base64.parse,\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n};\n\nimport * as crypto from './crypto';\nimport FireCryptReference from './FireCryptReference';\n\nexport default class FireCrypt {\n  constructor(db, options = {}, specification = {}) {\n    const dbIsNonNullObject = typeof db === 'object' && db !== null;\n    if (!dbIsNonNullObject || typeof db.app !== 'object' || typeof db.ref !== 'function') {\n      throw new Error(\n        `Expected first argument passed to FireCrypt constructor to be a Firebase Database instance, \n        but got \"${db}\".`\n      );\n    } else if (typeof options !== 'object' || options === null) {\n      throw new Error(\n        `Expected second argument passed to FireCrypt constructor to be an object, but got \"${options}\".`\n      );\n    } else if (typeof specification !== 'object' || specification === null) {\n      throw new Error(\n        `Expected third argument passed to FireCrypt constructor to be an object, but got \"${specification}\".`\n      );\n    }\n\n    this._db = db;\n\n    options.cacheSize = options.cacheSize || 5 * 1000 * 1000;\n    options.encryptionCacheSize = options.encryptionCacheSize || options.cacheSize;\n    options.decryptionCacheSize = options.decryptionCacheSize || options.cacheSize;\n\n    crypto.setStringEncryptionFunctions(crypto.throwNotSetUpError, crypto.throwNotSetUpError);\n\n    if (typeof LRUCache === 'function') {\n      crypto.setEncryptionCache(new LRUCache({\n        max: options.encryptionCacheSize, length: crypto.computeCacheItemSize\n      }));\n      crypto.setDecryptionCache(new LRUCache({\n        max: options.decryptionCacheSize, length: crypto.computeCacheItemSize\n      }));\n    }\n\n    switch (options.algorithm) {\n      case 'aes-siv':\n        if (!options.key) throw new Error('You must specify a key to use AES encryption.');\n        this.encryptionKeyCheckValue = setupAesSiv(options.key, options.keyCheckValue);\n        break;\n      case 'passthrough':\n        crypto.setStringEncryptionFunctions((str) => str, (str) => str);\n        break;\n      case 'none':\n        break;\n      default:\n        throw new Error('Unknown encryption algorithm \"' + options.algorithm + '\".');\n    }\n\n    crypto.setSpec(specification);\n\n    return () => {\n      return this;\n    };\n  }\n\n  get app() {\n    return this._db.app;\n  }\n\n  goOnline() {\n    return this._db.goOnline();\n  }\n\n  goOffline() {\n    return this._db.goOffline();\n  }\n\n  ref(pathOrRef) {\n    if (typeof pathOrRef !== 'undefined') {\n      const pathOrRefIsNonemptyString = typeof pathOrRef === 'string' && pathOrRef !== '';\n      const pathOrRefIsNonNullObject = typeof pathOrRef === 'object' && pathOrRef !== null;\n      const pathOrRefIsFirebaseRef =\n        pathOrRefIsNonNullObject &&\n        typeof pathOrRef.ref === 'object' &&\n        typeof pathOrRef.ref.transaction !== 'function';\n\n      if (!pathOrRefIsNonemptyString && !pathOrRefIsFirebaseRef) {\n        throw new Error(\n          `Expected first argument passed to ref() to be a non-empty string or a Firebase Database\n          reference, but got \"${pathOrRef}\".`\n        );\n      }\n    }\n\n    return new FireCryptReference(this._db.ref(pathOrRef));\n  }\n}\n\nfunction setupAesSiv(key, checkValue) {\n  const siv = CryptoJS.SIV.create(CryptoJS.enc.Base64.parse(key));\n  const encryptString = (str) => {\n    return CryptoJS.enc.Base64UrlSafe.stringify(siv.encrypt(str));\n  };\n  const decryptString = (str) => {\n    const result = siv.decrypt(CryptoJS.enc.Base64UrlSafe.parse(str));\n    if (result === false) {\n      const e = new Error('Wrong decryption key');\n      e.firecrypt = 'WRONG_KEY';\n      throw e;\n    }\n    return CryptoJS.enc.Utf8.stringify(result);\n  };\n\n  crypto.setStringEncryptionFunctions(encryptString, decryptString);\n\n  if (checkValue) decryptString(checkValue);\n  return encryptString(CryptoJS.enc.Base64UrlSafe.stringify(CryptoJS.lib.WordArray.random(10)));\n}\n"],"names":["_spec","_encryptString","_decryptString","_encryptionCache","_decryptionCache","setSpec","spec","cleanSpecification","def","path","keys","Object","i","length","key","encryptKeys","j","encryptKey","Error","test","slice","charAt","$","setStringEncryptionFunctions","encryptString","decryptString","throwNotSetUpError","e","firecrypt","computeCacheItemSize","value","encryptPath","rules","encrypt","encryptRef","ref","encryptedPath","refToPath","root","child","join","decryptRef","changed","decryptedPathSegment","decrypt","specForPath","transformValue","transform","transformTree","type","getType","transformedValue","hasOwnProperty","subDef","subValue","indexOf","keyParts","split","encrypted","pathStr","decodeURIComponent","toString","pattern","cacheKey","result","has","get","encryptValue","match","regex","patternRegexes","RegExp","replace","compilePattern","placeholder","part","set","toUpperCase","decryptedString","Number","typeCode","encryptedString","Array","isArray","String","Boolean","FireCryptSnapshot","snap","_ref","crypto","_path","this","_snap","_delegateSnapshot","methodName","apply","arguments","FireCryptReference","val","childPath","action","forEach","childSnap","hasChild","exportVal","FireCryptQuery","query","order","originalRef","_query","_order","_originalRef","eventType","callback","cancelCallback","context","on","call","firecryptCallback","off","successCallback","failureCallback","once","then","_orderBy","_checkCanSort","undefined","_delegate","by","keyEncrypted","equalTo","args","hasExtraKey","valueEncrypted","childKey","encryptedChildKey","subKey","childDef","childEncrypted","encryptedChildKeyCandidate","wrapQueryCallback","wrappedCallback","previousChildKey","FireCryptOnDisconnect","originalOnDisconnect","_originalOnDisconnect","_interceptOnDisconnectWrite","argIndex","prototype","_interceptPush","_interceptTransaction","_interceptOnDisconnect","_interceptQuery","_interceptWrite","childrenKeys","_interceptChildrenKeys","isEqual","parent","toJSON","otherRef","push","pushedRef","encryptedRef","decryptedPushedRef","catch","finally","some","map","onDisconnect","transaction","originalCompute","originalOnComplete","error","committed","snapshot","require","LRUCache","global","CryptoJS","enc","Base64UrlSafe","Base64","stringify","parse","db","options","specification","app","cache","_db","cacheSize","encryptionCacheSize","decryptionCacheSize","algorithm","encryptionKeyCheckValue","checkValue","siv","SIV","create","str","Utf8","lib","WordArray","random","setupAesSiv","keyCheckValue","goOnline","goOffline","pathOrRef","pathOrRefIsNonemptyString","pathOrRefIsFirebaseRef"],"mappings":"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"}